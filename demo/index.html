<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VN-Studio Demo - Virtual Navigator Renderer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      height: 100%;
      width: 100%;
      position: fixed;
      touch-action: none;
    }
    body {
      display: flex;
      flex-direction: column;
    }

    /* Barre du haut */
    #toolbar {
      background: #16213e;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #0f3460;
      z-index: 10;
      flex-shrink: 0;
    }
    #toolbar h1 {
      font-size: 14px;
      color: #e94560;
      margin-right: 8px;
    }
    #toolbar button, #toolbar select {
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #533483;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    #toolbar button:hover { background: #533483; }
    #toolbar label {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #toolbar input[type="checkbox"] { accent-color: #e94560; }
    #scene-info {
      margin-left: auto;
      font-size: 12px;
      color: #888;
    }

    /* Hamburger menu for mobile */
    #burger-btn {
      display: none;
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #533483;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
    }
    #burger-btn:hover { background: #533483; }
    #burger-menu {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 100;
    }
    #burger-menu.open { display: flex; }
    #burger-menu-content {
      background: #16213e;
      width: 280px;
      max-width: 85vw;
      height: 100%;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #burger-menu-content button,
    #burger-menu-content select {
      background: #0f3460;
      color: #e0e0e0;
      border: 1px solid #533483;
      padding: 12px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      width: 100%;
      text-align: left;
    }
    #burger-menu-content button:hover { background: #533483; }
    #burger-menu-content label {
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
    }
    #burger-menu-content .menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #533483;
      padding-bottom: 12px;
      margin-bottom: 4px;
    }
    #burger-menu-content .menu-header h2 {
      color: #e94560;
      font-size: 16px;
    }
    #burger-close {
      background: transparent;
      border: none;
      color: #e0e0e0;
      font-size: 24px;
      cursor: pointer;
      padding: 4px 8px;
      width: auto !important;
    }
    #burger-menu-content .menu-section {
      border-top: 1px solid #333;
      padding-top: 12px;
      margin-top: 4px;
    }
    #burger-menu-content .menu-section-title {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    /* Mobile styles */
    @media (max-width: 800px) {
      #burger-btn { display: block; }
      #toolbar .desktop-only { display: none; }
      #toolbar { gap: 8px; padding: 8px; }
      #toolbar h1 { font-size: 12px; margin-right: 4px; }
    }

    /* Zone de rendu - remplit tout l'espace restant */
    #canvas-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
      overflow: hidden;
    }
    #game-canvas {
      image-rendering: auto;
      cursor: default;
      touch-action: none;
    }

    /* Fullscreen */
    body.fullscreen #toolbar { display: none; }
    body.fullscreen #canvas-container { height: 100vh; }

    /* Panneau latéral scènes */
    #scene-list {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 220px;
      background: rgba(22, 33, 62, 0.95);
      overflow-y: auto;
      font-size: 11px;
      z-index: 5;
      border-right: 1px solid #0f3460;
      display: none;
    }
    #scene-list.visible { display: block; }
    #scene-list .scene-item {
      padding: 6px 10px;
      cursor: pointer;
      border-bottom: 1px solid #0f3460;
    }
    #scene-list .scene-item:hover { background: #0f3460; }
    #scene-list .scene-item.active { background: #533483; color: #fff; }
    #scene-list .scene-item .scene-name { font-weight: bold; }
    #scene-list .scene-item .scene-meta { color: #888; font-size: 10px; }

    /* Info tooltip */
    #tooltip {
      position: absolute;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 11px;
      pointer-events: none;
      display: none;
      z-index: 20;
      max-width: 300px;
      font-family: monospace;
    }

    /* PLAYHTML overlay */
    #html-overlay {
      position: absolute;
      background: #fff;
      border: 2px solid #333;
      z-index: 15;
      display: none;
      overflow: auto;
    }
    #html-overlay .html-close {
      position: absolute;
      top: 2px;
      right: 6px;
      cursor: pointer;
      font-size: 18px;
      color: #333;
      z-index: 1;
      background: rgba(255,255,255,0.8);
      padding: 0 4px;
    }
    #html-overlay .html-content {
      padding: 8px;
      font-family: 'Comic Sans MS', sans-serif;
      font-size: 12px;
      color: #000;
      overflow: auto;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    /* Loading screen overlay */
    #loading-overlay {
      position: absolute;
      inset: 0;
      background: #000;
      z-index: 30;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }
    #loading-overlay.visible { display: flex; }
    #loading-bar-bg {
      width: 300px;
      height: 12px;
      background: #333;
      border: 1px solid #555;
      margin-top: 20px;
    }
    #loading-bar-fill {
      height: 100%;
      background: #e94560;
      width: 0%;
      transition: width 0.1s;
    }
    #loading-text {
      color: #888;
      font-size: 12px;
      margin-top: 8px;
    }

    /* Drop zone */
    #dropzone {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      background: rgba(26, 26, 46, 0.95);
    }
    #dropzone.hidden { display: none; }
    #dropzone h2 { color: #e94560; margin-bottom: 16px; }
    #dropzone p { color: #888; margin: 4px 0; font-size: 14px; }
    #dropzone .drop-area {
      border: 2px dashed #533483;
      border-radius: 12px;
      padding: 40px 60px;
      text-align: center;
      cursor: pointer;
    }
    #dropzone .drop-area:hover { border-color: #e94560; }
    #dropzone .drop-area.dragover { background: rgba(83, 52, 131, 0.3); border-color: #e94560; }
  </style>
</head>
<body>

<div id="toolbar">
  <button id="burger-btn" onclick="openBurgerMenu()">&#9776;</button>
  <h1>VN-Studio</h1>
  <select id="vnd-select"><option value="">-- Charger VND --</option></select>
  <button id="btn-load" class="desktop-only">Fichier local</button>
  <button id="btn-load-res" class="desktop-only">Ressources locales</button>
  <button id="btn-scenes" class="desktop-only">Scènes</button>
  <button id="btn-prev">&larr;</button>
  <select id="scene-select"></select>
  <button id="btn-next">&rarr;</button>
  <label class="desktop-only"><input type="checkbox" id="chk-polygons" checked> Polygones</label>
  <label class="desktop-only"><input type="checkbox" id="chk-labels" checked> Labels</label>
  <label class="desktop-only"><input type="checkbox" id="chk-fill"> Remplir</label>
  <button id="btn-fullscreen" class="desktop-only">Plein écran</button>
  <button id="btn-debug" class="desktop-only">Debug</button>
  <span id="scene-info"></span>
</div>

<!-- Burger menu for mobile -->
<div id="burger-menu" onclick="if(event.target===this)this.classList.remove('open')">
  <div id="burger-menu-content">
    <div class="menu-header">
      <h2>Menu</h2>
      <button id="burger-close" onclick="document.getElementById('burger-menu').classList.remove('open')">&times;</button>
    </div>

    <div class="menu-section">
      <div class="menu-section-title">Fichiers</div>
      <button onclick="document.getElementById('btn-load').click();document.getElementById('burger-menu').classList.remove('open')">Fichier local</button>
      <button onclick="document.getElementById('btn-load-res').click();document.getElementById('burger-menu').classList.remove('open')">Ressources locales</button>
      <button onclick="document.getElementById('btn-scenes').click();document.getElementById('burger-menu').classList.remove('open')">Liste des scènes</button>
    </div>

    <div class="menu-section">
      <div class="menu-section-title">Affichage</div>
      <label><input type="checkbox" id="chk-polygons-mobile" checked onchange="document.getElementById('chk-polygons').checked=this.checked;document.getElementById('chk-polygons').dispatchEvent(new Event('change'))"> Polygones</label>
      <label><input type="checkbox" id="chk-labels-mobile" checked onchange="document.getElementById('chk-labels').checked=this.checked;document.getElementById('chk-labels').dispatchEvent(new Event('change'))"> Labels</label>
      <label><input type="checkbox" id="chk-fill-mobile" onchange="document.getElementById('chk-fill').checked=this.checked;document.getElementById('chk-fill').dispatchEvent(new Event('change'))"> Remplir polygones</label>
    </div>

    <div class="menu-section">
      <div class="menu-section-title">Outils</div>
      <button onclick="document.getElementById('btn-fullscreen').click();document.getElementById('burger-menu').classList.remove('open')">Plein écran</button>
      <button onclick="document.getElementById('btn-debug').click();document.getElementById('burger-menu').classList.remove('open')">Debug Panel</button>
    </div>
  </div>
</div>

<!-- Debug panel -->
<div id="debug-panel" style="display:none;position:fixed;right:0;top:0;bottom:0;width:360px;background:rgba(0,0,0,0.92);color:#0f0;font:11px monospace;z-index:50;overflow:auto;padding:8px;border-left:2px solid #333;">
  <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
    <button onclick="debugClearLog()" style="font-size:10px;padding:2px 6px;">Clear</button>
    <button onclick="debugDumpVars()" style="font-size:10px;padding:2px 6px;">Vars</button>
    <button onclick="debugDumpScene()" style="font-size:10px;padding:2px 6px;">Scene</button>
    <button onclick="debugDumpCmds()" style="font-size:10px;padding:2px 6px;">Cmds</button>
    <input id="debug-var-name" placeholder="var" style="width:60px;font-size:10px;padding:2px;">
    <input id="debug-var-val" placeholder="val" style="width:40px;font-size:10px;padding:2px;">
    <button onclick="debugSetVar()" style="font-size:10px;padding:2px 6px;">Set</button>
  </div>
  <div id="debug-log" style="white-space:pre-wrap;word-break:break-all;"></div>
</div>

<div id="canvas-container">
  <canvas id="game-canvas" width="640" height="480"></canvas>
  <div id="scene-list"></div>
  <div id="tooltip"></div>
  <div id="html-overlay"><span class="html-close" onclick="closeHtmlOverlay()">&times;</span><div class="html-content"></div></div>
  <div id="scene-html" style="position:absolute;background:transparent;z-index:14;display:none;overflow:hidden;"><div class="scene-html-content" style="padding:4px;font-family:'Comic Sans MS',sans-serif;font-size:12px;color:#000;overflow:auto;width:100%;height:100%;box-sizing:border-box;-webkit-overflow-scrolling:touch;touch-action:pan-y;overscroll-behavior:contain;"></div></div>
  <div id="loading-overlay"><canvas id="loading-bg" width="640" height="480"></canvas><div id="loading-bar-bg"><div id="loading-bar-fill"></div></div><div id="loading-text"></div></div>
  <div id="dropzone">
    <div class="drop-area" id="drop-area">
      <h2>VN-Studio Demo</h2>
      <p>Glissez un fichier .vnd ici</p>
      <p>ou cliquez pour sélectionner</p>
      <p style="margin-top:16px;font-size:11px;color:#666">
        Optionnel: glissez aussi un dossier de ressources (BMP, WAV)
      </p>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept=".vnd" style="display:none">
<input type="file" id="res-input" webkitdirectory style="display:none">

<script>
// =============================================================================
// VND PARSER (inline, exact copy of parse-vnd-universal.js logic)
// =============================================================================

function readBS(buf, o) {
  if (o + 4 > buf.byteLength) return null;
  var view = new DataView(buf);
  var len = view.getUint32(o, true);
  if (len === 0) return { s: '', l: 4 };
  if (len > 100000 || o + 4 + len > buf.byteLength) return null;
  var bytes = new Uint8Array(buf, o + 4, len);
  var s = '';
  for (var i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
  return { s: s, l: 4 + len };
}

function readObject(buf, view, p) {
  var type = view.getUint32(p, true); p += 4;
  var bs = readBS(buf, p);
  var str = bs ? bs.s : '';
  p += bs ? bs.l : 4;
  return { type: type, string: str, endPos: p };
}

function readStringCollection(buf, view, p) {
  var count = view.getUint32(p, true); p += 4;
  var items = [];
  for (var i = 0; i < count; i++) {
    var subIndex = view.getUint32(p, true); p += 4;
    var obj = readObject(buf, view, p);
    items.push({ subIndex: subIndex, type: obj.type, string: obj.string });
    p = obj.endPos;
  }
  return { items: items, endPos: p };
}

function readCommand(buf, view, p, streamVersion) {
  var strCol = readStringCollection(buf, view, p);
  p = strCol.endPos;
  var commandType = view.getUint32(p, true); p += 4;
  var paramPairCount = view.getUint32(p, true); p += 4;
  var paramPairs = [];
  if (paramPairCount > 0 && paramPairCount < 10000) {
    for (var i = 0; i < paramPairCount; i++) {
      var a = view.getInt32(p, true); p += 4;
      var b = view.getInt32(p, true); p += 4;
      paramPairs.push({ a: a, b: b });
    }
  }
  var flags = 0;
  if (streamVersion >= 0x2000c) {
    flags = view.getUint32(p, true); p += 4;
  }
  return { strings: strCol.items, commandType: commandType, paramPairCount: paramPairCount, paramPairs: paramPairs, flags: flags, endPos: p };
}

function readContentCollection(buf, view, p, sv) {
  var count = view.getUint32(p, true); p += 4;
  var cmds = [];
  for (var i = 0; i < count; i++) {
    var cmd = readCommand(buf, view, p, sv);
    cmds.push(cmd); p = cmd.endPos;
  }
  return { commands: cmds, endPos: p };
}

function readScene(buf, view, p, sv) {
  var nameBS = readBS(buf, p); if (!nameBS) return null; p += nameBS.l;
  var flagBytes = []; for (var fb = 0; fb < 4; fb++) flagBytes.push(new Uint8Array(buf)[p + fb]); p += 4;
  var prop1 = view.getUint32(p, true); p += 4;
  var prop2 = view.getUint32(p, true); p += 4;
  var prop3 = view.getUint32(p, true); p += 4;

  var s1 = readBS(buf, p); p += s1 ? s1.l : 4;
  var s2 = readBS(buf, p); p += s2 ? s2.l : 4;
  var val1 = view.getUint32(p, true); p += 4;
  var s3 = readBS(buf, p); p += s3 ? s3.l : 4;
  var val2 = view.getUint32(p, true); p += 4;
  var s4 = readBS(buf, p); p += s4 ? s4.l : 4;
  var val3 = view.getUint32(p, true); p += 4;
  var s5 = readBS(buf, p); p += s5 ? s5.l : 4;
  var val4 = view.getUint32(p, true); p += 4;
  var s6 = readBS(buf, p); p += s6 ? s6.l : 4;
  var val5 = view.getUint32(p, true); p += 4;

  var rect = {
    left: view.getInt32(p, true), top: view.getInt32(p+4, true),
    right: view.getInt32(p+8, true), bottom: view.getInt32(p+12, true)
  }; p += 16;

  view.getUint32(p, true); p += 4; // val6

  var hotspotCount = view.getUint32(p, true); p += 4;
  var hotspot = null;
  if (hotspotCount > 0) {
    var timerValue = view.getUint32(p, true); p += 4;
    var collCount = view.getUint32(p, true); p += 4;
    var objects = [];
    for (var hi = 0; hi < collCount; hi++) {
      var obj = readObject(buf, view, p);
      objects.push({ type: obj.type, string: obj.string });
      p = obj.endPos;
    }
    hotspot = { timerValue: timerValue, objects: objects };
  }

  var cmdListValue = view.getInt32(p, true); p += 4;
  var cmdListData = [];
  if (cmdListValue !== 0) {
    for (var ci = 0; ci < 5; ci++) { cmdListData.push(view.getUint32(p, true)); p += 4; }
  }

  var contentCol = readContentCollection(buf, view, p, sv);
  p = contentCol.endPos;

  return {
    name: nameBS.s, flagBytes: flagBytes, prop1: prop1, prop2: prop2, prop3: prop3,
    fields: {
      string1: s1 ? s1.s : '', string2: s2 ? s2.s : '', val1: val1,
      string3: s3 ? s3.s : '', val2: val2, string4: s4 ? s4.s : '', val3: val3,
      resource: s5 ? s5.s : '', val4: val4, string6: s6 ? s6.s : '', val5: val5
    },
    rect: rect, hotspotCount: hotspotCount, hotspot: hotspot,
    cmdListValue: cmdListValue, cmdListData: cmdListData,
    commands: contentCol.commands, endPos: p
  };
}

function parseVND(arrayBuffer) {
  var buf = arrayBuffer;
  var view = new DataView(buf);
  var p = 5; // skip stream header

  var magic = readBS(buf, p); p += magic.l;
  if (magic.s !== 'VNFILE') throw new Error('Invalid magic: ' + magic.s);
  var version = readBS(buf, p); p += version.l;
  var sceneCount = view.getUint32(p, true); p += 4;
  var projectName = readBS(buf, p); p += projectName.l;
  var editor = readBS(buf, p); p += editor.l;
  var serial = readBS(buf, p); p += serial.l;
  var projectIDStr = readBS(buf, p); p += projectIDStr.l;
  var registry = readBS(buf, p); p += registry.l;
  var width = view.getUint32(p, true); p += 4;
  var height = view.getUint32(p, true); p += 4;
  var depth = view.getUint32(p, true); p += 4;
  var flag = view.getUint32(p, true); p += 4;
  var u1 = view.getUint32(p, true); p += 4;
  var u2 = view.getUint32(p, true); p += 4;
  var reserved = view.getUint32(p, true); p += 4;
  var dllPath = readBS(buf, p); p += dllPath.l;
  var varCount = view.getUint32(p, true); p += 4;

  var vars = [];
  for (var vi = 0; vi < varCount; vi++) {
    var vname = readBS(buf, p); p += vname.l;
    var vval = view.getUint32(p, true); p += 4;
    vars.push({ name: vname.s, value: vval });
  }

  var vp = version.s.split('.');
  var sv = (parseInt(vp[0]) << 16) | parseInt(vp[1] || '0');

  var scenes = [];
  for (var si = 0; si < sceneCount; si++) {
    var scene = readScene(buf, view, p, sv);
    if (!scene) break;
    scenes.push(scene); p = scene.endPos;
  }

  return {
    header: {
      magic: magic.s, version: version.s, sceneCount: sceneCount,
      projectName: projectName.s, editor: editor.s,
      width: width, height: height, depth: depth
    },
    variables: vars, scenes: scenes,
    bytesRemaining: buf.byteLength - p
  };
}

// =============================================================================
// COMMANDE TYPES
// =============================================================================

var CMD_NAMES = {
  0:'QUIT', 1:'ABOUT', 2:'PREFS', 3:'PREV', 4:'NEXT', 5:'ZOOM',
  6:'SCENE', 7:'HOTSPOT', 8:'TIPTEXT', 9:'PLAYAVI', 10:'PLAYBMP',
  11:'PLAYWAV', 12:'PLAYMID', 13:'PLAYHTML', 14:'ZOOMIN', 15:'ZOOMOUT',
  16:'PAUSE', 17:'EXEC', 18:'EXPLORE', 19:'PLAYCDA', 20:'PLAYSEQ',
  21:'IF', 22:'SET_VAR', 23:'INC_VAR', 24:'DEC_VAR', 25:'INVALIDATE',
  26:'DEFCURSOR', 27:'ADDBMP', 28:'DELBMP', 29:'SHOWBMP', 30:'HIDEBMP',
  31:'RUNPRJ', 32:'UPDATE', 33:'RUNDLL', 34:'MSGBOX', 35:'PLAYCMD',
  36:'CLOSEWAV', 37:'CLOSEDLL', 38:'PLAYTEXT', 39:'FONT', 40:'REM',
  41:'ADDTEXT', 42:'DELOBJ', 43:'SHOWOBJ', 44:'HIDEOBJ',
  45:'LOAD', 46:'SAVE', 47:'CLOSEAVI', 48:'CLOSEMID', 105:'POLYGON'
};

// Convertir 2 paires (rect top-left/bottom-right) en 4 coins
function expandRect(pairs) {
  if (pairs.length === 2) {
    return [
      { a: pairs[0].a, b: pairs[0].b },
      { a: pairs[1].a, b: pairs[0].b },
      { a: pairs[1].a, b: pairs[1].b },
      { a: pairs[0].a, b: pairs[1].b }
    ];
  }
  return pairs;
}

// Couleurs de polygones par type de commande
var POLY_COLORS = {
  100: 'rgba(255,100,100,0.4)',
  101: 'rgba(100,255,100,0.4)',
  103: 'rgba(255,255,100,0.4)',
  105: 'rgba(100,150,255,0.4)',
  106: 'rgba(255,150,100,0.4)',
  107: 'rgba(150,100,255,0.4)',
  108: 'rgba(100,255,200,0.4)',
};
var POLY_STROKE = {
  100: '#ff6464',
  101: '#64ff64',
  103: '#ffff64',
  105: '#6496ff',
  106: '#ff9664',
  107: '#9664ff',
  108: '#64ffc8',
};

// =============================================================================
// APP STATE
// =============================================================================

var project = null;
var currentSceneIndex = -1;
var currentVNDEntry = null; // Current VND_LIST entry for cross-project navigation
var sceneHistory = []; // Stack for PREV navigation - stores {entry, sceneIndex} for cross-project support
var waitingForVideoEnd = false; // Block clicks while video plays with deferred navigation
var resources = {}; // path -> Image
var showPolygons = true;
var showLabels = true;
var fillPolygons = false;
var hoveredCmd = null;
var scrollX = 0; // offset de scroll horizontal pour scènes larges
var activePlayText = null; // text from IF-triggered playtext actions
var activePlayTextFont = null; // font for activePlayText
var activePlayTexts = []; // array of {text, font} for multiple IF playtext lines
var overlayTexts = {}; // name -> { text, fontSize, x, y, w, h, color }
var toolbarSceneIndex = -1; // index of the "Toolbar" scene

var canvas = document.getElementById('game-canvas');
var ctx = canvas.getContext('2d');
var container = document.getElementById('canvas-container');

// =============================================================================
// CANVAS SCALING (640x480 interne, CSS plein conteneur)
// =============================================================================

// Calculer la largeur réelle d'une scène (max X des polygones ou header)
function getSceneWidth(scene) {
  var w = project ? project.header.width : 640;
  if (!scene) return w;
  // Utiliser la largeur de l'image de fond si chargée
  var resKey = scene.fields.resource ? scene.fields.resource.toLowerCase().replace(/\\/g, '/') : '';
  if (resources[resKey] && resources[resKey].naturalWidth > w) {
    w = resources[resKey].naturalWidth;
  }
  // Fallback: max X des polygones
  scene.commands.forEach(function(cmd) {
    cmd.paramPairs.forEach(function(p) {
      if (p.a > w) w = p.a + 1;
    });
  });
  return w;
}

function resizeCanvas() {
  var cw = container.clientWidth;
  var ch = container.clientHeight;
  var gameW = project ? project.header.width : 640;
  var gameH = project ? project.header.height : 480;
  canvas.width = gameW;
  canvas.height = gameH;
  var scale = Math.min(cw / gameW, ch / gameH);
  var dispW = Math.floor(gameW * scale);
  var dispH = Math.floor(gameH * scale);
  canvas.style.width = dispW + 'px';
  canvas.style.height = dispH + 'px';

  render();
}

window.addEventListener('resize', resizeCanvas);

// Convertir coordonnées écran -> coordonnées jeu
function screenToGame(clientX, clientY) {
  var rect = canvas.getBoundingClientRect();
  var gameW = project ? project.header.width : 640;
  var gameH = project ? project.header.height : 480;
  var scaleX = gameW / rect.width;
  var scaleY = gameH / rect.height;
  return {
    x: (clientX - rect.left) * scaleX + scrollX,
    y: (clientY - rect.top) * scaleY
  };
}

// =============================================================================
// RENDU
// =============================================================================

function render() {
  if (!project || currentSceneIndex < 0) return;
  var scene = project.scenes[currentSceneIndex];
  var w = project.header.width;
  var h = project.header.height;
  var sceneW = getSceneWidth(scene);

  // Limiter le scroll
  var maxScroll = Math.max(0, sceneW - w);
  if (scrollX > maxScroll) scrollX = maxScroll;
  if (scrollX < 0) scrollX = 0;

  // Fond
  ctx.fillStyle = '#2a2a4a';
  ctx.fillRect(0, 0, w, h);

  // Appliquer le scroll
  ctx.save();
  ctx.translate(-scrollX, 0);

  // Image de fond si disponible
  var resKey = scene.fields.resource.toLowerCase().replace(/\\/g, '/');
  if (resources[resKey]) {
    ctx.drawImage(resources[resKey], 0, 0);
  } else if (scene.fields.resource) {
    // Fond placeholder avec nom de ressource
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#444';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Resource: ' + scene.fields.resource, w/2, h/2);
    ctx.textAlign = 'start';
  }

  // Overlay images (ADDBMP) — scene overlays only (not toolbar zone)
  Object.keys(overlayImages).forEach(function(name) {
    var ov = overlayImages[name];
    if (ov.visible && ov.img.complete && ov.y < 400) {
      ctx.drawImage(ov.img, ov.x, ov.y, ov.w, ov.h);
    }
  });

  // Polygones
  if (showPolygons) {
    scene.commands.forEach(function(cmd, idx) {
      if (cmd.paramPairs.length < 2) return;
      var pts = expandRect(cmd.paramPairs);
      var color = POLY_COLORS[cmd.commandType] || 'rgba(200,200,200,0.3)';
      var stroke = POLY_STROKE[cmd.commandType] || '#ccc';

      ctx.beginPath();
      ctx.moveTo(pts[0].a, pts[0].b);
      for (var i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].a, pts[i].b);
      }
      ctx.closePath();

      if (fillPolygons || cmd === hoveredCmd) {
        ctx.fillStyle = cmd === hoveredCmd ? 'rgba(255,255,255,0.3)' : color;
        ctx.fill();
      }

      ctx.strokeStyle = cmd === hoveredCmd ? '#fff' : stroke;
      ctx.lineWidth = cmd === hoveredCmd ? 2.5 : 1.5;
      ctx.stroke();

      // Labels
      if (showLabels) {
        var cx = 0, cy = 0;
        pts.forEach(function(p) { cx += p.a; cy += p.b; });
        cx /= pts.length;
        cy /= pts.length;

        var label = CMD_NAMES[cmd.commandType] || ('CMD_' + cmd.commandType);
        // Extraire la cible scène si string type 6
        var sceneStr = cmd.strings.find(function(s) { return s.type === 6; });
        if (sceneStr) {
          var si = parseInt(sceneStr.string, 10);
          if (!isNaN(si) && project && si >= 1 && (si - 1) < project.scenes.length && project.scenes[si - 1].name) {
            label = si + ': ' + project.scenes[si - 1].name;
          } else {
            label = sceneStr.string;
          }
        }

        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        var tw = ctx.measureText(label).width;
        ctx.fillRect(cx - tw/2 - 2, cy - 6, tw + 4, 14);
        ctx.fillStyle = '#fff';
        ctx.fillText(label, cx, cy + 4);
        ctx.textAlign = 'start';
      }
    });
  }

  // Render a PLAYTEXT string on the canvas
  // textVal: "x1 y1 x2 y2 flags text", fontVal: "size flags color fontname" (optional)
  function renderPlayTextBox(textVal, fontVal, noBackground) {
    var tp = textVal.match(/^(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+\d+\s+([\s\S]+)$/);
    if (!tp) return;
    var tx = parseInt(tp[1]), ty = parseInt(tp[2]);
    var tx2 = parseInt(tp[3]), ty2 = parseInt(tp[4]);
    var tw = tx2 - tx, th = ty2 - ty;
    var text = tp[5];
    if (tw <= 0) tw = 300;
    if (th <= 0) th = 40;

    var fontSize = 14, fontColor = '#ffffff', fontName = 'Comic Sans MS';
    if (fontVal) {
      var fp = fontVal.match(/^(-?\d+)\s+\d+\s+(#[0-9a-fA-F]+)\s+(.+)$/);
      if (fp) {
        fontSize = Math.abs(parseInt(fp[1]));
        fontColor = fp[2];
        fontName = fp[3];
      }
    }
    if (fontSize < 6) fontSize = 12;
    // Ensure text is readable on dark background: convert dark colors to white
    if (fontColor) {
      var hex = fontColor.replace('#', '');
      var r = parseInt(hex.substr(0, 2), 16) || 0;
      var g = parseInt(hex.substr(2, 2), 16) || 0;
      var b = parseInt(hex.substr(4, 2), 16) || 0;
      var luminance = (0.299 * r + 0.587 * g + 0.114 * b);
      if (luminance < 128) fontColor = '#ffffff';
    }

    ctx.font = fontSize + 'px "' + fontName + '", sans-serif';

    // Word-wrap text into lines
    var words = text.split(' ');
    var lines = [];
    var line = '';
    var maxW = tw - 8;
    var maxLineWidth = 0;
    for (var wi = 0; wi < words.length; wi++) {
      var test = line ? line + ' ' + words[wi] : words[wi];
      var testWidth = ctx.measureText(test).width;
      if (testWidth > maxW && line) {
        var lineWidth = ctx.measureText(line).width;
        if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
        lines.push(line);
        line = words[wi];
      } else {
        line = test;
      }
    }
    if (line) {
      var lineWidth = ctx.measureText(line).width;
      if (lineWidth > maxLineWidth) maxLineWidth = lineWidth;
      lines.push(line);
    }

    var lineH = fontSize + 4;
    var textH = lines.length * lineH;
    // Always use calculated text height, ignore VND coordinates (often much larger)
    var boxH = textH + 8;
    // Dynamic width: use actual text width + small padding (8px = 4px each side)
    var boxW = maxLineWidth + 8;

    // Only draw background if this is a standalone text (not part of multi-line set)
    if (!noBackground) {
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillRect(tx, ty, boxW, boxH);
    }
    ctx.fillStyle = fontColor;
    ctx.textAlign = 'start';
    for (var li = 0; li < lines.length; li++) {
      ctx.fillText(lines[li], tx + 4, ty + fontSize + 2 + li * lineH);
    }
  }

  // PLAYTEXT overlay pour la commande survolée
  if (hoveredCmd) {
    var fontStr = hoveredCmd.strings.find(function(s) { return s.type === 39; });
    var fontVal = fontStr ? fontStr.string : null;
    // Render ALL type 38 strings (multiple lines at different positions)
    hoveredCmd.strings.forEach(function(s) {
      if (s.type === 38 && s.string) {
        renderPlayTextBox(s.string, fontVal);
      }
    });
  }

  // IF-triggered playtext (from hover evaluation or executeAction)
  activePlayTexts.forEach(function(pt) {
    renderPlayTextBox(pt.text, pt.font);
  });
  if (activePlayText) {
    renderPlayTextBox(activePlayText, activePlayTextFont);
  }

  ctx.restore(); // fin du scroll

  // Toolbar overlays (fixed, not scrolled)
  if (isToolbarVisible()) {
    {
      Object.keys(overlayImages).forEach(function(name) {
        var ov = overlayImages[name];
        if (ov.visible && ov.img.complete && ov.y >= 400) {
          ctx.drawImage(ov.img, ov.x, ov.y, ov.w, ov.h);
        }
      });
      // Toolbar texts (ADDTEXT)
      Object.keys(overlayTexts).forEach(function(name) {
        var ot = overlayTexts[name];
        var displayText = ot.text.replace(/<(\w+)>/g, function(m, vname) {
          return String(getVar(vname));
        });
        ctx.font = 'bold ' + ot.fontSize + 'px "Comic Sans MS", sans-serif';
        ctx.fillStyle = ot.color;
        ctx.textAlign = 'start';
        ctx.fillText(displayText, ot.x, ot.y + ot.fontSize);
      });
    }
  }

  // Info scène (fixe, pas scrollée)
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, w, 22);
  ctx.font = '12px monospace';
  ctx.fillStyle = '#e94560';
  ctx.fillText('Scene ' + (currentSceneIndex + 1) + '/' + project.scenes.length + ': "' + scene.name + '"', 8, 15);
  var info = scene.commands.length + ' cmds, ' + scene.commands.filter(function(c) { return c.paramPairs.length > 0; }).length + ' polys';
  if (scene.hotspot) info += ', hotspot timer=' + scene.hotspot.timerValue;
  ctx.fillStyle = '#888';
  ctx.fillText(info, w - ctx.measureText(info).width - 8, 15);

  // Barre de scroll horizontale si scène plus large que la fenêtre
  if (sceneW > w) {
    var barY = h - 6;
    var barH = 4;
    var viewRatio = w / sceneW;
    var barW = Math.max(20, w * viewRatio);
    var barX = (scrollX / (sceneW - w)) * (w - barW);
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(0, barY, w, barH);
    ctx.fillStyle = 'rgba(233,69,96,0.7)';
    ctx.fillRect(barX, barY, barW, barH);
  }
}

// =============================================================================
// COMMAND EXECUTION ENGINE
// =============================================================================

// --- AUDIO ---
var audioElements = {}; // key -> HTMLAudioElement
var audioUnlocked = false;
var pendingAudioPlays = []; // audio elements waiting for user gesture
var audioContext = null;

// Unlock audio on first user interaction (critical for mobile browsers)
function unlockAudio() {
  if (audioUnlocked) return;

  // Create and resume AudioContext (required for iOS/Android)
  try {
    if (!audioContext) {
      var AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (AudioCtx) audioContext = new AudioCtx();
    }
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume();
    }
  } catch (e) {
    console.warn('AudioContext unlock failed:', e);
  }

  // Play silent audio to unlock on iOS (belt and suspenders)
  var silentAudio = new Audio('data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAYYoRwmHAAAAAAD/+1DEAAAFeANX9AAACM8K6f80IAIAAD/JBAEBQdB0P/E4Pg+CAIAgCAYfB8uD4Pgh//y4nw+H5c+D7//8vKAgGPt/Lhj//////1gQB8Hw///AgCAI=');
  silentAudio.play().catch(function() {});

  audioUnlocked = true;
  console.log('Audio unlocked');

  // Replay any pending audio
  pendingAudioPlays.forEach(function(audio) {
    audio.play().catch(function() {});
  });
  pendingAudioPlays = [];

  // Play pending video if any (that was blocked by autoplay policy)
  if (pendingVideoPlay && currentVideo === pendingVideoPlay) {
    var video = pendingVideoPlay;
    pendingVideoPlay = null;
    video.play().catch(function(e) {
      console.warn('Video play still failed:', e.message);
    });
  }

  // Re-trigger scene auto-play audio if nothing played yet
  if (project && currentSceneIndex >= 0) {
    var scene = project.scenes[currentSceneIndex];
    if (scene.fields.string3 && Object.keys(audioElements).length === 0) {
      var wavFile = scene.fields.string3;
      var loops = scene.fields.val2 || 1;
      playWav(wavFile + ' ' + loops);
    }
  }
}

['click', 'touchstart', 'touchend', 'keydown'].forEach(function(evt) {
  document.addEventListener(evt, unlockAudio, { once: false, capture: true });
});

function resolveWavPath(wavRef) {
  var normalized = wavRef.toLowerCase().replace(/\\/g, '/');
  var wavDir = 'digit/'; // default
  if (currentVNPConfig) {
    var dir = currentVNPConfig['WAV'] || '';
    wavDir = dir.replace(/\\/g, '/');
    if (wavDir && !wavDir.endsWith('/')) wavDir += '/';
  }
  return '/game-data/' + currentBasePath + wavDir + normalized;
}

function playWav(wavStr) {
  // Format: "filename loop_count" ex: "music.wav 2"
  var parts = wavStr.trim().split(/\s+/);
  var file = parts[0];
  var loops = parseInt(parts[1]) || 1;
  var url = resolveWavPath(file);
  var key = file.toLowerCase();

  // If same sound is already playing, don't restart
  if (audioElements[key] && !audioElements[key].paused && !audioElements[key].ended) {
    return;
  }

  var audio = new Audio(url);
  audio.loop = (loops > 1 || loops === 0); // 0 = infinite
  audioElements[key] = audio;
  recentlyStartedAudio[key] = true;
  audio.play().catch(function(e) {
    if (e.name === 'NotAllowedError') {
      console.warn('Audio blocked (waiting for user gesture):', file);
      pendingAudioPlays.push(audio);
    } else {
      console.warn('Audio play failed:', url, e.message);
    }
  });
  console.log('PLAYWAV:', file, 'loops:', loops);
}

function stopAllAudio() {
  Object.keys(audioElements).forEach(function(key) {
    audioElements[key].pause();
    audioElements[key].currentTime = 0;
  });
  audioElements = {};
}

// Collect WAV keys that a scene will play on enter (auto-execute commands)
function getSceneAutoWavKeys(scene) {
  var keys = {};
  scene.commands.forEach(function(cmd) {
    if (cmd.paramPairs.length > 0) return; // interactive, skip
    cmd.strings.forEach(function(s) {
      if (s.type === 11 && s.string) {
        keys[s.string.trim().split(/\s+/)[0].toLowerCase()] = true;
      }
    });
  });
  return keys;
}

var recentlyStartedAudio = {}; // keys started in current click cycle

// Stop audio except keys that the next scene will play or were just started
function stopAudioExcept(keepKeys) {
  Object.keys(audioElements).forEach(function(key) {
    if (!keepKeys[key] && !recentlyStartedAudio[key]) {
      audioElements[key].pause();
      audioElements[key].currentTime = 0;
      delete audioElements[key];
    }
  });
  recentlyStartedAudio = {};
}

// --- RUNPRJ ---
// Map VNP path to VND_LIST entry
// Input: "..\france\france.vnp 18" -> { entry, sceneIndex }
function parseRunPrj(runPrjStr) {
  var parts = runPrjStr.trim().split(/\s+/);
  var vnpPath = parts[0].toLowerCase().replace(/\\/g, '/');
  var sceneIdx = parseInt(parts[1]) || 1;

  // Extract folder/name from path like "../france/france.vnp"
  var match = vnpPath.match(/([^/]+)\/([^/]+)\.vnp$/);
  if (!match) return null;

  var folder = match[1];
  var name = match[2];

  // Find in VND_LIST
  var entry = VND_LIST.find(function(e) {
    return e.base.replace(/\/$/, '').toLowerCase() === folder ||
           e.vnd.toLowerCase().indexOf(name + '.vnd') >= 0;
  });

  return entry ? { entry: entry, sceneIndex: sceneIdx } : null;
}

function executeRunPrj(runPrjStr) {
  var parsed = parseRunPrj(runPrjStr);
  if (!parsed) {
    console.warn('RUNPRJ: cannot resolve', runPrjStr);
    return;
  }
  console.log('RUNPRJ:', parsed.entry.name, 'scene', parsed.sceneIndex);
  stopAllAudio();

  currentBasePath = parsed.entry.base;
  var targetScene = parsed.sceneIndex;
  var targetEntry = parsed.entry;

  // Load both VNP and VND, but wait for BOTH before going to scene
  // This ensures currentVNPConfig is set correctly for video path resolution
  var vnpPromise = fetch('/game-data/' + parsed.entry.vnp)
    .then(function(r) { return r.text(); })
    .then(function(text) {
      currentVNPConfig = parseVNP(text);
      console.log('VNP loaded for', targetEntry.name, ':', currentVNPConfig);
    })
    .catch(function() { currentVNPConfig = null; });

  var vndPromise = fetch('/game-data/' + targetEntry.vnd)
    .then(function(r) { return r.arrayBuffer(); });

  // Wait for both VNP and VND to load
  Promise.all([vnpPromise, vndPromise]).then(function(results) {
    var buf = results[1];
    loadVNDFile(buf, targetEntry.vnd, true);
    currentVNDEntry = targetEntry; // Track current VND for cross-project PREV
    // Update VND selector
    var vndIdx = VND_LIST.indexOf(targetEntry);
    if (vndIdx >= 0) document.getElementById('vnd-select').value = vndIdx;
    preloadResources(function() {
      if (targetScene >= 1 && (targetScene - 1) < project.scenes.length) {
        goToScene(targetScene - 1);
      } else {
        goToScene(0);
      }
    });
  }).catch(function(e) {
    console.error('RUNPRJ load failed:', e);
  });
}

// --- VARIABLES ---
var gameVars = {}; // variable store: { name: value }

function getVar(name) {
  return gameVars[name.toLowerCase()] || 0;
}

function setVar(name, val) {
  gameVars[name.toLowerCase()] = val;
  console.log('SET_VAR:', name, '=', val);
}

// --- IF EVALUATOR ---
// Format: "variable op value then action [else action]"
// Actions: "runprj path sceneIdx", "scene idx", "dec_var name val", "inc_var name val",
//          "playavi path flags", "set_var name val"
function evaluateIf(ifStr) {
  // Split on " then " to get condition and actions
  var thenIdx = ifStr.indexOf(' then ');
  if (thenIdx < 0) return null;

  var condStr = ifStr.substring(0, thenIdx).trim();
  var rest = ifStr.substring(thenIdx + 6).trim();

  // Parse condition: "variable op value"
  var condMatch = condStr.match(/^(\S+)\s*(>=|<=|!=|<>|=|<|>)\s*(-?\d+)$/);
  if (!condMatch) return null;

  var varName = condMatch[1];
  var op = condMatch[2];
  var val = parseInt(condMatch[3]);
  var actual = getVar(varName);

  var result = false;
  switch (op) {
    case '=': result = (actual === val); break;
    case '<': result = (actual < val); break;
    case '>': result = (actual > val); break;
    case '>=': result = (actual >= val); break;
    case '<=': result = (actual <= val); break;
    case '!=': case '<>': result = (actual !== val); break;
  }

  // Split on " else " — careful: "else" can appear in action strings
  // Look for " else " that's followed by a known command keyword
  var elseIdx = -1;
  var elseMatch = rest.match(/\s+else\s+(runprj|scene|dec_var|inc_var|set_var|playavi|playwav|playbmp|playtext|playhtml|addbmp|delbmp|closewav|if)\s/i);
  if (elseMatch) {
    elseIdx = rest.indexOf(elseMatch[0]);
  } else {
    // Try simple " else " split
    var simpleElse = rest.indexOf(' else ');
    if (simpleElse >= 0) elseIdx = simpleElse;
  }

  var thenAction, elseAction;
  if (elseIdx >= 0) {
    thenAction = rest.substring(0, elseIdx).trim();
    elseAction = rest.substring(elseIdx + 6).trim();
  } else {
    thenAction = rest.trim();
    elseAction = null;
  }

  console.log('IF:', varName, op, val, '(actual=' + actual + ') →', result ? 'THEN' : 'ELSE');
  return result ? thenAction : elseAction;
}

// Execute an action string (from IF then/else branch)
function executeAction(action) {
  if (!action) return;
  var parts = action.trim().split(/\s+/);
  var cmd = parts[0].toLowerCase();

  if (cmd === 'runprj') {
    executeRunPrj(parts.slice(1).join(' '));
  } else if (cmd === 'scene') {
    var idx = parseInt(parts[1]);
    if (!isNaN(idx) && idx >= 1 && (idx - 1) < project.scenes.length) {
      goToScene(idx - 1);
    }
  } else if (cmd === 'set_var') {
    setVar(parts[1], parseInt(parts[2]) || 0);
  } else if (cmd === 'inc_var') {
    setVar(parts[1], getVar(parts[1]) + (parseInt(parts[2]) || 1));
  } else if (cmd === 'dec_var') {
    setVar(parts[1], getVar(parts[1]) - (parseInt(parts[2]) || 1));
  } else if (cmd === 'playwav') {
    playWav(parts.slice(1).join(' '));
  } else if (cmd === 'playavi') {
    playAvi(parts.slice(1).join(' '));
  } else if (cmd === 'playhtml') {
    playHtml(parts.slice(1).join(' '));
  } else if (cmd === 'playbmp') {
    addBmpOverlay('_play_' + Date.now() + ' ' + parts.slice(1).join(' '));
  } else if (cmd === 'addbmp') {
    addBmpOverlay(parts.slice(1).join(' '));
  } else if (cmd === 'delbmp') {
    delBmpOverlay(parts[1] || '');
  } else if (cmd === 'showbmp') {
    showBmpOverlay(parts[1] || '');
  } else if (cmd === 'hidebmp') {
    hideBmpOverlay(parts[1] || '');
  } else if (cmd === 'closewav') {
    stopAllAudio();
  } else if (cmd === 'addtext') {
    addTextOverlay(parts.slice(1).join(' '));
  } else if (cmd === 'closedll') {
    // DLL not supported, ignore
  } else if (cmd === 'font') {
    // Font change from IF action - store for next playtext
    activePlayTextFont = parts.slice(1).join(' ');
  } else if (cmd === 'invalidate' || cmd === 'update') {
    render();
  } else if (cmd === 'playtext') {
    // playtext x1 y1 x2 y2 flags text
    activePlayText = parts.slice(1).join(' ');
    render();
  } else if (cmd === 'if') {
    // Nested IF: "if var op val then action"
    var nestedAction = evaluateIf(parts.slice(1).join(' '));
    if (nestedAction) executeAction(nestedAction);
  } else {
    console.log('Unhandled action:', action);
  }
}

// --- OVERLAY BMP ---
var overlayImages = {}; // name -> { img, x, y, w, h, visible }

function resolveOverlayPath(bmpRef) {
  // Could be relative like "rollover\all.bmp" or absolute path
  var normalized = bmpRef.toLowerCase().replace(/\\/g, '/');
  var imgDir = 'img24/';
  if (currentVNPConfig) {
    var dir = currentVNPConfig['IMG24'] || currentVNPConfig['IMG8'] || '';
    imgDir = dir.replace(/\\/g, '/');
    if (imgDir && !imgDir.endsWith('/')) imgDir += '/';
  }
  // Also try with ../ paths for cross-module resources
  if (normalized.indexOf('..') >= 0) {
    // "../barre/images/barre.bmp" -> resolve relative to game-data
    var parts = normalized.split('/');
    var resolved = [];
    // Start from current base
    var baseParts = currentBasePath.replace(/\/$/, '').split('/');
    resolved = baseParts.slice();
    parts.forEach(function(p) {
      if (p === '..') resolved.pop();
      else if (p !== '.') resolved.push(p);
    });
    return '/game-data/' + resolved.join('/');
  }
  return '/game-data/' + currentBasePath + imgDir + normalized;
}

function addBmpOverlay(addbmpStr) {
  // Format: "name path flags x y [x2 y2]"
  // When 7 parts: x,y = top-left, x2,y2 = bottom-right (coordinates, not width/height)
  // When 5 parts: x,y = position, size from image
  var parts = addbmpStr.trim().split(/\s+/);
  if (parts.length < 4) return;
  var name = parts[0].toLowerCase();
  var path = parts[1];
  // Skip flags (parts[2])
  var x = parseInt(parts[3]) || 0;
  var y = parseInt(parts[4]) || 0;
  var x2 = parts.length > 5 ? parseInt(parts[5]) : 0;
  var y2 = parts.length > 6 ? parseInt(parts[6]) : 0;

  var url = resolveOverlayPath(path);
  var img = new Image();
  var gen = overlayGeneration;
  img.onload = function() {
    if (gen !== overlayGeneration) return; // scene changed, discard stale overlay
    var w, h;
    if (x2 > x && y2 > y) {
      w = x2 - x; h = y2 - y;
    } else {
      w = img.width; h = img.height;
    }
    overlayImages[name] = { img: img, x: x, y: y, w: w, h: h, visible: true };
    console.log('ADDBMP:', name, url, x, y, w, h);
    render();
  };
  img.onerror = function() { console.warn('ADDBMP failed:', url); };
  img.src = url;
}

function delBmpOverlay(name) {
  name = name.trim().toLowerCase();
  if (overlayImages[name]) {
    delete overlayImages[name];
    console.log('DELBMP:', name);
    render();
  }
}

function showBmpOverlay(name) {
  name = name.trim().toLowerCase();
  if (overlayImages[name]) { overlayImages[name].visible = true; render(); }
}

function hideBmpOverlay(name) {
  name = name.trim().toLowerCase();
  if (overlayImages[name]) { overlayImages[name].visible = false; render(); }
}

function addTextOverlay(val) {
  // Format: "name fontSize x y w h flags <varname>" or "name fontSize x y w h flags text"
  var parts = val.trim().split(/\s+/);
  if (parts.length < 7) return;
  var name = parts[0].toLowerCase();
  var fontSize = parseInt(parts[1]) || 14;
  var x = parseInt(parts[2]) || 0;
  var y = parseInt(parts[3]) || 0;
  var w = parseInt(parts[4]) || 200;
  var h = parseInt(parts[5]) || 30;
  // parts[6] = flags
  var textPart = parts.slice(7).join(' ');
  overlayTexts[name] = { text: textPart, fontSize: fontSize, x: x, y: y, w: w, h: h, color: '#ffffff' };
  console.log('ADDTEXT:', name, '=', textPart, 'at', x, y);
  render();
}

// --- PLAYHTML ---
function resolveHtmlPath(htmlRef) {
  var normalized = htmlRef.toLowerCase().replace(/\\/g, '/');
  var htmlDir = 'html/';
  if (currentVNPConfig) {
    var dir = currentVNPConfig['TXT'] || '';
    htmlDir = dir.replace(/\\/g, '/');
    if (htmlDir && !htmlDir.endsWith('/')) htmlDir += '/';
  }
  if (normalized.indexOf('..') >= 0) {
    var parts = normalized.split('/');
    var resolved = currentBasePath.replace(/\/$/, '').split('/').slice();
    parts.forEach(function(p) {
      if (p === '..') resolved.pop();
      else if (p !== '.') resolved.push(p);
    });
    return '/game-data/' + resolved.join('/');
  }
  return '/game-data/' + currentBasePath + htmlDir + normalized;
}

function playHtml(htmlStr) {
  // Format: "filename [flags x y w h]" or just "filename"
  var parts = htmlStr.trim().split(/\s+/);
  if (parts.length < 1) return;
  var file = parts[0];

  // Don't overwrite an already visible HTML overlay (first playhtml wins)
  // This fixes bonus questions showing wrong HTM when multiple bonusX=1
  var overlay = document.getElementById('html-overlay');
  if (overlay.style.display === 'block') {
    console.log('PLAYHTML skipped (overlay already visible):', file);
    return;
  }

  // Mark that playhtml was triggered (prevents string6 default HTM from loading)
  playhtmlTriggered = true;

  var gameW = project ? project.header.width : 640;
  var gameH = project ? project.header.height : 480;
  var flags = parts.length > 1 ? parseInt(parts[1]) || 0 : 0;
  var x = parts.length > 2 ? parseInt(parts[2]) || 0 : 0;
  var y = parts.length > 3 ? parseInt(parts[3]) || 0 : 0;
  var w = parts.length > 4 ? parseInt(parts[4]) || gameW : gameW;
  var h = parts.length > 5 ? parseInt(parts[5]) || gameH : gameH;

  var url = resolveHtmlPath(file);
  console.log('PLAYHTML:', file, 'at', x, y, w, h);

  // Position overlay relative to canvas
  var rect = canvas.getBoundingClientRect();
  var scaleX = rect.width / gameW;
  var scaleY = rect.height / gameH;

  var content = overlay.querySelector('.html-content');

  overlay.style.left = (rect.left - container.getBoundingClientRect().left + x * scaleX) + 'px';
  overlay.style.top = (rect.top - container.getBoundingClientRect().top + y * scaleY) + 'px';
  overlay.style.width = (w * scaleX) + 'px';
  overlay.style.height = (h * scaleY) + 'px';
  overlay.style.display = 'block';

  fetchLatin1(url).then(function(html) {
    var bodyMatch = html.match(/<body[^>]*>([\s\S]*)<\/body>/i);
    content.innerHTML = bodyMatch ? bodyMatch[1] : html;
  }).catch(function(e) {
    content.innerHTML = '<p style="color:red">Erreur: ' + e.message + '</p>';
  });
}

// Fetch a file as Latin1 (ISO-8859-1) text
function fetchLatin1(url) {
  return fetch(url).then(function(r) { return r.arrayBuffer(); }).then(function(buf) {
    return new TextDecoder('iso-8859-1').decode(buf);
  });
}

// --- SCENE HTML (string6 auto-loaded HTM) ---
function loadSceneHtml(htmFile, rect) {
  var url = resolveHtmlPath(htmFile);
  console.log('Scene HTM:', htmFile, 'rect:', rect);

  var el = document.getElementById('scene-html');
  var content = el.querySelector('.scene-html-content');

  // Position relative to canvas
  var canvasRect = canvas.getBoundingClientRect();
  var contRect = container.getBoundingClientRect();
  var gameW = project ? project.header.width : 640;
  var gameH = project ? project.header.height : 480;
  var scaleX = canvasRect.width / gameW;
  var scaleY = canvasRect.height / gameH;

  el.style.left = (canvasRect.left - contRect.left + rect.left * scaleX) + 'px';
  el.style.top = (canvasRect.top - contRect.top + rect.top * scaleY) + 'px';
  el.style.width = ((rect.right - rect.left) * scaleX) + 'px';
  el.style.height = ((rect.bottom - rect.top) * scaleY) + 'px';
  el.style.display = 'block';
  // Scale font size with canvas
  content.style.fontSize = Math.max(10, Math.round(12 * scaleY)) + 'px';

  fetchLatin1(url).then(function(html) {
    var bodyMatch = html.match(/<body[^>]*>([\s\S]*)<\/body>/i);
    content.innerHTML = bodyMatch ? bodyMatch[1] : html;
  }).catch(function(e) {
    console.warn('Scene HTM load failed:', url, e.message);
    el.style.display = 'none';
  });
}

function closeSceneHtml() {
  document.getElementById('scene-html').style.display = 'none';
}

var pendingAfterHtml = null; // command to resume after HTML overlay closed

function closeHtmlOverlay() {
  document.getElementById('html-overlay').style.display = 'none';
  // Resume pending command processing or navigation
  if (pendingAfterHtml) {
    var pending = pendingAfterHtml;
    pendingAfterHtml = null;
    if (pending.nav) {
      doNavigation(pending.nav);
    } else if (pending.cmd) {
      resumeCommandProcessing(pending.cmd, pending.startIdx);
    }
  }
}

// --- PLAYAVI ---
var currentVideo = null;
var pendingVideoPlay = null; // Video waiting for user gesture to play
var pendingVideoNav = null; // Navigation to execute after video ends

function resolveAviPath(aviRef) {
  var normalized = aviRef.toLowerCase().replace(/\\/g, '/');
  var aviDir = 'movie/';
  if (currentVNPConfig) {
    var dir = currentVNPConfig['AVI'] || '';
    aviDir = dir.replace(/\\/g, '/');
    if (aviDir && !aviDir.endsWith('/')) aviDir += '/';
  }
  if (normalized.indexOf('..') >= 0) {
    var parts = normalized.split('/');
    var resolved = currentBasePath.replace(/\/$/, '').split('/').slice();
    parts.forEach(function(p) {
      if (p === '..') resolved.pop();
      else if (p !== '.') resolved.push(p);
    });
    return '/game-data/' + resolved.join('/');
  }
  return '/game-data/' + currentBasePath + aviDir + normalized;
}

function playAvi(aviStr) {
  // Format: "filename flags [x1 y1 x2 y2]"
  var parts = aviStr.trim().split(/\s+/);
  if (parts.length < 1) return;
  var file = parts[0];
  var flags = parseInt(parts[1]) || 0;
  var x1 = parseInt(parts[2]) || 0;
  var y1 = parseInt(parts[3]) || 0;
  var x2 = parseInt(parts[4]) || 0;
  var y2 = parseInt(parts[5]) || 0;

  var url = resolveAviPath(file);
  var webmUrl = url.replace(/\.avi$/i, '.webm');
  console.log('PLAYAVI:', file, 'pos:', x1, y1, x2, y2);

  closeVideo();

  var rect = canvas.getBoundingClientRect();
  var gameW = project ? project.header.width : 640;
  var gameH = project ? project.header.height : 480;
  var scaleX = rect.width / gameW;
  var scaleY = rect.height / gameH;

  var video = document.createElement('video');
  video.playsInline = true;
  video.setAttribute('playsinline', ''); // iOS requires attribute
  video.setAttribute('webkit-playsinline', ''); // older iOS
  var srcWebm = document.createElement('source');
  srcWebm.src = webmUrl;
  srcWebm.type = 'video/webm';
  var srcAvi = document.createElement('source');
  srcAvi.src = url;
  srcAvi.type = 'video/avi';
  video.appendChild(srcWebm);
  video.appendChild(srcAvi);
  video.style.position = 'absolute';
  video.style.zIndex = '16';
  video.style.background = '#000';

  var contRect = container.getBoundingClientRect();
  if (x2 > x1 && y2 > y1) {
    // Positioned overlay: x1,y1 = top-left, x2,y2 = bottom-right in game coords
    video.style.left = (rect.left - contRect.left + x1 * scaleX) + 'px';
    video.style.top = (rect.top - contRect.top + y1 * scaleY) + 'px';
    video.style.width = ((x2 - x1) * scaleX) + 'px';
    video.style.height = ((y2 - y1) * scaleY) + 'px';
  } else {
    // Fullscreen over canvas
    video.style.left = (rect.left - contRect.left) + 'px';
    video.style.top = (rect.top - contRect.top) + 'px';
    video.style.width = rect.width + 'px';
    video.style.height = rect.height + 'px';
  }

  video.addEventListener('ended', function() { closeVideo(); });
  video.addEventListener('error', function() {
    console.warn('AVI playback failed (codec not supported):', url);
    closeVideo();
  });
  // Click on video: if paused (autoplay blocked), try to play; if playing, close
  video.addEventListener('click', function() {
    if (video.paused) {
      video.play().catch(function() { closeVideo(); });
    } else {
      closeVideo();
    }
  });

  // Add to DOM immediately (needed for video events to work)
  container.appendChild(video);
  currentVideo = video;

  // Try to play - handle autoplay policy on mobile
  var playPromise = video.play();
  if (playPromise !== undefined) {
    playPromise.catch(function(e) {
      if (e.name === 'NotAllowedError') {
        console.warn('Video autoplay blocked, waiting for user interaction:', file);
        // Store as pending video to play on next user interaction
        pendingVideoPlay = video;
      } else {
        console.warn('Video play failed:', e.message);
      }
    });
  } else {
    // Old browsers without promise - just add to DOM
    container.appendChild(video);
    currentVideo = video;
  }
}

function closeVideo() {
  if (currentVideo) {
    currentVideo.pause();
    currentVideo.src = ''; // Stop loading
    if (currentVideo.parentNode) currentVideo.parentNode.removeChild(currentVideo);
    currentVideo = null;
  }
  pendingVideoPlay = null;
  waitingForVideoEnd = false; // Re-enable clicks
  // Execute pending navigation if video was blocked by autoplay and just finished
  if (pendingVideoNav) {
    var nav = pendingVideoNav;
    pendingVideoNav = null;
    console.log('closeVideo: executing pending nav', nav);
    doNavigation(nav);
  }
}

// --- SCENE COMMANDS ---
// Execute all string sub-commands of a VND command
function executeStringCommand(strType, strValue) {
  var val = (strValue || '').trim();
  if (!val && strType !== 25 && strType !== 36) return;

  switch (strType) {
    case 11: // PLAYWAV
      playWav(val);
      break;
    case 22: // SET_VAR: "name value"
      var sp = val.split(/\s+/);
      if (sp.length >= 2) setVar(sp[0], parseInt(sp[1]) || 0);
      break;
    case 23: // INC_VAR: "name value"
      var ip = val.split(/\s+/);
      if (ip.length >= 2) setVar(ip[0], getVar(ip[0]) + (parseInt(ip[1]) || 1));
      break;
    case 24: // DEC_VAR: "name value"
      var dp = val.split(/\s+/);
      if (dp.length >= 2) setVar(dp[0], getVar(dp[0]) - (parseInt(dp[1]) || 1));
      break;
    case 27: // ADDBMP
      addBmpOverlay(val);
      break;
    case 28: // DELBMP
      delBmpOverlay(val);
      break;
    case 29: // SHOWBMP
      showBmpOverlay(val);
      break;
    case 30: // HIDEBMP
      hideBmpOverlay(val);
      break;
    case 36: // CLOSEWAV
      stopAllAudio();
      break;
    case 16: // PAUSE
      // TODO: implement actual pause/delay
      break;
    case 25: // INVALIDATE
      render();
      break;
    case 26: // DEFCURSOR
      // Could set cursor style, ignore for now
      break;
    case 32: // UPDATE
      render();
      break;
    case 33: // RUNDLL
      console.log('RUNDLL (not implemented):', val);
      break;
    case 40: // REM (comment)
      break;
    case 13: // PLAYHTML
      playHtml(val);
      break;
    case 9: // PLAYAVI
      playAvi(val);
      break;
    case 10: // PLAYBMP (direct, not named overlay)
      // Format: "path flags x y" — similar to ADDBMP but unnamed
      var bp = val.split(/\s+/);
      if (bp.length >= 1) {
        addBmpOverlay('_playbmp_' + Date.now() + ' ' + val);
      }
      break;
    case 41: // ADDTEXT: "name fontSize x y w h flags <varname>"
      addTextOverlay(val);
      break;
    // Types handled elsewhere: 6 (SCENE), 21 (IF), 31 (RUNPRJ), 38 (PLAYTEXT), 39 (FONT), 3 (PREV), 7 (HOTSPOT)
    default:
      break;
  }
}

// Execute non-interactive commands of a scene (on scene enter)
var overlayGeneration = 0; // incremented on scene change to cancel stale async loads
var playhtmlTriggered = false; // track if playhtml was called during scene load

function executeSceneCommands(scene) {
  // Clear overlays from previous scene
  overlayImages = {};
  overlayGeneration++;
  playhtmlTriggered = false; // reset for new scene

  // Reset click-guard variable 'jeu' to 0 on scene entry
  // This variable is used in library scenes to prevent double-clicks:
  // Pattern: INC_VAR jeu 1 + IF jeu = 1 then runprj
  // Without resetting, returning to the scene leaves jeu at 1, breaking future clicks
  if (gameVars['jeu'] !== undefined) {
    gameVars['jeu'] = 0;
  }

  // First pass: Execute display conditions (addbmp/delbmp/showbmp/hidebmp) from ALL commands
  // This restores the correct visual state based on variables when returning to a scene
  // (e.g., collected items should stay hidden even after leaving and returning)
  scene.commands.forEach(function(cmd) {
    cmd.strings.forEach(function(s) {
      if (s.type === 21) {
        var lowerStr = s.string.toLowerCase();
        // Only execute IF conditions that affect display state
        if (lowerStr.includes('addbmp') || lowerStr.includes('delbmp') ||
            lowerStr.includes('showbmp') || lowerStr.includes('hidebmp')) {
          var action = evaluateIf(s.string);
          if (action) {
            var actLower = action.toLowerCase().trim().split(/\s+/)[0];
            // Only execute display-related actions
            if (actLower === 'addbmp' || actLower === 'delbmp' ||
                actLower === 'showbmp' || actLower === 'hidebmp') {
              executeAction(action);
            }
          }
        }
      }
    });
  });

  // Second pass: Execute non-interactive commands (without polygons)
  scene.commands.forEach(function(cmd) {
    // Only execute commands without polygons (auto-execute on scene load)
    // Commands with polygons are interactive (click/hover)
    if (cmd.paramPairs.length > 0) return;

    cmd.strings.forEach(function(s) {
      // Skip types handled interactively
      if (s.type === 6 || s.type === 38 || s.type === 39 || s.type === 3 || s.type === 7) return;

      if (s.type === 21) {
        // IF - evaluate and execute (skip display commands, already handled in first pass)
        var action = evaluateIf(s.string);
        if (action) {
          var actLower = action.toLowerCase().trim().split(/\s+/)[0];
          if (actLower !== 'addbmp' && actLower !== 'delbmp' &&
              actLower !== 'showbmp' && actLower !== 'hidebmp') {
            executeAction(action);
          }
        }
        return;
      }

      executeStringCommand(s.type, s.string);
    });
  });

  // Init variables from VND header (only if not already set)
  if (project && project.variables) {
    project.variables.forEach(function(v) {
      if (gameVars[v.name.toLowerCase()] === undefined) {
        gameVars[v.name.toLowerCase()] = v.value;
      }
    });
  }

  // Auto-load HTM from scene string6 field ONLY if no playhtml was triggered
  // This allows conditional playhtml (like bonus questions) to override the default
  if (scene.fields.string6 && scene.fields.string6.toLowerCase().endsWith('.htm')) {
    if (!playhtmlTriggered) {
      var htmToLoad = scene.fields.string6;

      // WORKAROUND: Fix for bonus question scenes with incorrect VND conditions
      // The VND has wrong mappings (e.g., scene expects bonus1,5,4 but navigations use bonus1,2,3)
      // Auto-detect which bonusX=1 and load the corresponding bonusX.htm
      if (htmToLoad.toLowerCase() === 'bonus1.htm') {
        for (var bi = 1; bi <= 12; bi++) {
          if (getVar('bonus' + bi) === 1) {
            htmToLoad = 'bonus' + bi + '.htm';
            console.log('Bonus question workaround: bonus' + bi + '=1, loading', htmToLoad);
            break;
          }
        }
      }

      loadSceneHtml(htmToLoad, scene.rect);
    } else {
      console.log('Skipping string6 HTM (playhtml already triggered):', scene.fields.string6);
    }
  }

  // Note: string4 AVI field is NOT auto-played here.
  // Videos should be triggered by commands (type 9 PLAYAVI) for proper control.
  // The string4 field seems to be informational/unused in most VNDs.

  // Special case: Interactive commands with PLAYAVI + PREV
  // These are "farewell videos" that should play on scene arrival, not on click
  // The button click should just do PREV (return)
  // Check both direct PLAYAVI (type 9) and PLAYAVI inside IF conditions (type 21)
  scene.commands.forEach(function(cmd, cmdIndex) {
    if (cmd.paramPairs.length === 0) return; // Only interactive commands

    // Check for direct PLAYAVI (type 9)
    var hasDirectPlayAvi = cmd.strings.some(function(s) { return s.type === 9; });

    // Check for PLAYAVI inside IF conditions (type 21)
    var hasIfPlayAvi = cmd.strings.some(function(s) {
      if (s.type !== 21) return false;
      var str = s.string.toLowerCase();
      return str.indexOf('playavi') >= 0;
    });

    var hasPlayAvi = hasDirectPlayAvi || hasIfPlayAvi;

    // Check for direct PREV (type 3) or PREV inside IF conditions
    var hasDirectPrev = cmd.strings.some(function(s) { return s.type === 3; });
    var hasIfPrev = cmd.strings.some(function(s) {
      if (s.type !== 21) return false;
      var str = s.string.toLowerCase();
      // Check if "prev" appears as an action (not as part of variable name)
      return /\bthen\s+prev\b/.test(str) || /\belse\s+prev\b/.test(str);
    });

    var hasPrev = hasDirectPrev || hasIfPrev;

    console.log('Auto-play check C' + cmdIndex + ': hasPlayAvi=' + hasPlayAvi +
                ' (direct=' + hasDirectPlayAvi + ', if=' + hasIfPlayAvi +
                '), hasPrev=' + hasPrev +
                ' (direct=' + hasDirectPrev + ', if=' + hasIfPrev + ')');

    if (hasPlayAvi && hasPrev) {
      // Mark command for special handling (skip PLAYAVI on click)
      cmd.autoPlayedVideo = true;
      console.log('Auto-play: marking C' + cmdIndex + ' as autoPlayedVideo');

      // Find and auto-play the video now
      // First check direct PLAYAVI
      var aviStr = cmd.strings.find(function(s) { return s.type === 9; });
      if (aviStr) {
        console.log('Auto-playing video from PLAYAVI+PREV command:', aviStr.string);
        playAvi(aviStr.string);
      } else {
        // Check IF conditions for PLAYAVI
        var ifStr = cmd.strings.find(function(s) {
          return s.type === 21 && s.string.toLowerCase().indexOf('playavi') >= 0;
        });
        if (ifStr) {
          // Parse the IF to get the PLAYAVI action
          var action = evaluateIf(ifStr.string);
          if (action) {
            var actParts = action.trim().split(/\s+/);
            if (actParts[0].toLowerCase() === 'playavi') {
              console.log('Auto-playing video from IF+PLAYAVI+PREV command:', actParts.slice(1).join(' '));
              playAvi(actParts.slice(1).join(' '));
            }
          }
        }
      }
    }
  });

  // Special case: Interactive commands with ADDBMP + PREV (but no PLAYAVI)
  // These are "static farewell scenes" with an image overlay
  // The ADDBMP should show on scene arrival, not on click
  scene.commands.forEach(function(cmd, cmdIndex) {
    if (cmd.paramPairs.length === 0) return; // Only interactive commands
    if (cmd.autoPlayedVideo) return; // Already handled as video scene

    // Check for ADDBMP (type 27)
    var hasAddBmp = cmd.strings.some(function(s) { return s.type === 27; });

    // Check for PREV (direct or in IF)
    var hasDirectPrev = cmd.strings.some(function(s) { return s.type === 3; });
    var hasIfPrev = cmd.strings.some(function(s) {
      if (s.type !== 21) return false;
      var str = s.string.toLowerCase();
      return /\bthen\s+prev\b/.test(str) || /\belse\s+prev\b/.test(str);
    });
    var hasPrev = hasDirectPrev || hasIfPrev;

    // Check there's NO PLAYAVI (those are handled above)
    var hasPlayAvi = cmd.strings.some(function(s) { return s.type === 9; });

    if (hasAddBmp && hasPrev && !hasPlayAvi) {
      console.log('Auto-showing ADDBMP for ADDBMP+PREV command C' + cmdIndex);
      cmd.autoShowedBmp = true;
      // Execute all ADDBMP commands in this command
      cmd.strings.forEach(function(s) {
        if (s.type === 27) {
          console.log('Auto ADDBMP:', s.string);
          addBmpOverlay(s.string);
        }
      });
    }
  });
}

function isToolbarVisible() {
  if (toolbarSceneIndex < 0 || !project || currentSceneIndex === toolbarSceneIndex) return false;
  var scene = project.scenes[currentSceneIndex];
  var resKey = scene.fields.resource.toLowerCase().replace(/\\/g, '/');
  var bgImg = resources[resKey];
  return !(bgImg && bgImg.height >= 480);
}

function executeToolbar() {
  // Execute the toolbar scene's C0 command strings to add barre overlay + conditional icons
  if (toolbarSceneIndex < 0 || !project) return;
  var tbScene = project.scenes[toolbarSceneIndex];
  if (!tbScene || !tbScene.commands.length) return;
  var cmd = tbScene.commands[0]; // C0 is the main toolbar setup command
  cmd.strings.forEach(function(s) {
    if (s.type === 39 || s.type === 38 || s.type === 3 || s.type === 7) return;
    if (s.type === 21) {
      var action = evaluateIf(s.string);
      if (action) executeAction(action);
    } else if (s.type === 33) {
      // RUNDLL - skip
    } else {
      executeStringCommand(s.type, s.string);
    }
  });
}

// =============================================================================
// HIT TESTING
// =============================================================================

function pointInPolygon(x, y, pairs) {
  if (pairs.length < 3) return false;
  var inside = false;
  for (var i = 0, j = pairs.length - 1; i < pairs.length; j = i++) {
    var xi = pairs[i].a, yi = pairs[i].b;
    var xj = pairs[j].a, yj = pairs[j].b;
    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

function isPolygonInBounds(pairs, sceneW) {
  // Check if at least part of the polygon is within the scene image
  var minX = Infinity;
  for (var i = 0; i < pairs.length; i++) {
    if (pairs[i].a < minX) minX = pairs[i].a;
  }
  return minX < sceneW;
}

function findCommandAtPoint(x, y) {
  if (!project || currentSceneIndex < 0) return null;
  var scene = project.scenes[currentSceneIndex];
  var sceneW = getSceneWidth(scene);
  for (var i = scene.commands.length - 1; i >= 0; i--) {
    var cmd = scene.commands[i];
    if (cmd.paramPairs.length >= 2 && isPolygonInBounds(cmd.paramPairs, sceneW) && pointInPolygon(x, y, expandRect(cmd.paramPairs))) {
      return cmd;
    }
  }
  // Check toolbar commands for hover
  if (isToolbarVisible()) {
    var tbScene = project.scenes[toolbarSceneIndex];
    for (var j = tbScene.commands.length - 1; j >= 0; j--) {
      var tbCmd = tbScene.commands[j];
      if (tbCmd.paramPairs.length >= 2 && pointInPolygon(x, y, expandRect(tbCmd.paramPairs))) {
        return tbCmd;
      }
    }
  }
  return null;
}

// Pour le clic : priorité aux commandes navigables (avec string type 6)
// Un rollover plein écran ne doit pas bloquer un polygone de navigation en dessous
function findClickableCommandAtPoint(x, y) {
  if (!project || currentSceneIndex < 0) return null;
  var scene = project.scenes[currentSceneIndex];
  var navigable = null;
  var fallback = null;
  for (var i = scene.commands.length - 1; i >= 0; i--) {
    var cmd = scene.commands[i];
    if (cmd.paramPairs.length >= 2 && pointInPolygon(x, y, expandRect(cmd.paramPairs))) {
      var hasScene = cmd.strings.some(function(s) { return s.type === 6; });
      if (hasScene && !navigable) {
        navigable = cmd;
      }
      if (!fallback) {
        fallback = cmd;
      }
    }
  }
  return navigable || fallback;
}

function findAllCommandsAtPoint(x, y) {
  if (!project || currentSceneIndex < 0) return [];
  var scene = project.scenes[currentSceneIndex];
  var sceneW = getSceneWidth(scene);
  var result = [];
  for (var i = scene.commands.length - 1; i >= 0; i--) {
    var cmd = scene.commands[i];
    if (cmd.paramPairs.length >= 2 && isPolygonInBounds(cmd.paramPairs, sceneW) && pointInPolygon(x, y, expandRect(cmd.paramPairs))) {
      result.push(cmd);
    }
  }
  // Also check toolbar scene commands if toolbar is visible
  if (isToolbarVisible()) {
    var tbScene = project.scenes[toolbarSceneIndex];
    for (var j = tbScene.commands.length - 1; j >= 0; j--) {
      var tbCmd = tbScene.commands[j];
      if (tbCmd.paramPairs.length >= 2 && pointInPolygon(x, y, expandRect(tbCmd.paramPairs))) {
        result.push(tbCmd);
      }
    }
  }
  return result;
}

// =============================================================================
// INTERACTIONS
// =============================================================================

canvas.addEventListener('mousemove', function(e) {
  var pos = screenToGame(e.clientX, e.clientY);
  var cmd = findCommandAtPoint(pos.x, pos.y);

  if (cmd !== hoveredCmd) {
    hoveredCmd = cmd;
    activePlayTexts = [];
    canvas.style.cursor = cmd ? 'pointer' : 'default';
    if (cmd) evaluateHoverEffects(cmd);
    render();
  }

  // Tooltip
  var tooltip = document.getElementById('tooltip');
  if (cmd) {
    var lines = [CMD_NAMES[cmd.commandType] || 'CMD_' + cmd.commandType];
    cmd.strings.forEach(function(s) {
      lines.push('  [' + s.type + '] ' + s.string);
    });
    if (cmd.flags) lines.push('  flags=' + cmd.flags);
    tooltip.textContent = lines.join('\n');
    tooltip.style.whiteSpace = 'pre';
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 12) + 'px';
    tooltip.style.top = (e.clientY + 12) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

// Evaluate IF conditions on a command for HOVER (visual effects only: playtext, addbmp, delbmp, showbmp, hidebmp)
function evaluateHoverEffects(cmd) {
  activePlayTexts = [];
  // Get font from command
  var fontStr = cmd.strings.find(function(s) { return s.type === 39; });
  var font = fontStr ? fontStr.string : null;

  cmd.strings.forEach(function(s) {
    if (s.type === 21) {
      var action = evaluateIfReadOnly(s.string);
      if (!action) return;
      var parts = action.trim().split(/\s+/);
      var act = parts[0].toLowerCase();
      if (act === 'playtext') {
        activePlayTexts.push({ text: parts.slice(1).join(' '), font: font });
      } else if (act === 'addbmp') {
        addBmpOverlay(parts.slice(1).join(' '));
      } else if (act === 'delbmp') {
        delBmpOverlay(parts[1] || '');
      } else if (act === 'showbmp') {
        showBmpOverlay(parts[1] || '');
      } else if (act === 'hidebmp') {
        hideBmpOverlay(parts[1] || '');
      }
    }
  });
}

// Read-only IF evaluator (same as evaluateIf but doesn't log)
function evaluateIfReadOnly(ifStr) {
  var thenIdx = ifStr.indexOf(' then ');
  if (thenIdx < 0) return null;

  var condStr = ifStr.substring(0, thenIdx).trim();
  var rest = ifStr.substring(thenIdx + 6).trim();

  var condMatch = condStr.match(/^(\S+)\s*(>=|<=|!=|<>|=|<|>)\s*(-?\d+)$/);
  if (!condMatch) return null;

  var varName = condMatch[1];
  var op = condMatch[2];
  var val = parseInt(condMatch[3]);
  var actual = getVar(varName);

  var result = false;
  switch (op) {
    case '=': result = (actual === val); break;
    case '<': result = (actual < val); break;
    case '>': result = (actual > val); break;
    case '>=': result = (actual >= val); break;
    case '<=': result = (actual <= val); break;
    case '!=': case '<>': result = (actual !== val); break;
  }

  var elseIdx = -1;
  var elseMatch = rest.match(/\s+else\s+(runprj|scene|dec_var|inc_var|set_var|playavi|playwav|playbmp|playtext|playhtml|addbmp|delbmp|closewav|if)\s/i);
  if (elseMatch) {
    elseIdx = rest.indexOf(elseMatch[0]);
  } else {
    var simpleElse = rest.indexOf(' else ');
    if (simpleElse >= 0) elseIdx = simpleElse;
  }

  var thenAction, elseAction;
  if (elseIdx >= 0) {
    thenAction = rest.substring(0, elseIdx).trim();
    elseAction = rest.substring(elseIdx + 6).trim();
  } else {
    thenAction = rest.trim();
    elseAction = null;
  }

  return result ? thenAction : elseAction;
}

// Action commune clic / tap
function handleCommandClick(cmd) {
  console.log('Click: CMD_' + cmd.commandType, cmd.strings.map(function(s) { return '[' + s.type + ']' + s.string; }).join(' | '));
  // If this command had auto-played video and video is still playing, close it first
  if (cmd.autoPlayedVideo && currentVideo) {
    console.log('Closing auto-played video on button click');
    closeVideo();
  }
  resumeCommandProcessing(cmd, 0);
}

function resumeCommandProcessing(cmd, startIdx) {
  // Two-pass: execute ALL side-effects first, then navigate/show HTML last.
  // This ensures SET_VAR, INC_VAR, ADDBMP etc. run even when followed by SCENE.
  var deferredNav = null;   // { type:'scene'|'runprj', value:string }
  var deferredHtml = null;  // { value:string, idx:number }
  var videoPlaying = false;

  for (var si = startIdx; si < cmd.strings.length; si++) {
    var s = cmd.strings[si];

    if (s.type === 21) {
      var action = evaluateIf(s.string);
      if (action) {
        var actParts = action.trim().split(/\s+/);
        var actCmd = actParts[0].toLowerCase();
        if (actCmd === 'playhtml') {
          if (!deferredHtml) deferredHtml = { value: actParts.slice(1).join(' '), idx: si };
        } else if (actCmd === 'scene') {
          if (!deferredNav) deferredNav = { type: 'scene', value: actParts.slice(1).join(' ') };
        } else if (actCmd === 'runprj') {
          if (!deferredNav) deferredNav = { type: 'runprj', value: actParts.slice(1).join(' ') };
        } else if (actCmd === 'playavi') {
          // PLAYAVI from IF condition - execute and track for video deferral
          // Skip if video was auto-played on scene load (PLAYAVI+PREV pattern)
          if (!cmd.autoPlayedVideo) {
            playAvi(actParts.slice(1).join(' '));
            videoPlaying = true;
          }
        } else if (actCmd === 'prev') {
          if (!deferredNav) deferredNav = { type: 'prev', value: '' };
        } else {
          executeAction(action);
        }
      }
    } else if (s.type === 9) {
      // Skip PLAYAVI if video was auto-played on scene load (PLAYAVI+PREV pattern)
      if (!cmd.autoPlayedVideo) {
        playAvi(s.string);
        videoPlaying = true;
      }
    } else if (s.type === 6) {
      if (!deferredNav) deferredNav = { type: 'scene', value: s.string };
    } else if (s.type === 31) {
      if (!deferredNav) deferredNav = { type: 'runprj', value: s.string };
    } else if (s.type === 13) {
      if (!deferredHtml) deferredHtml = { value: s.string, idx: si };
    } else if (s.type === 3) {
      // PREV - go back to previous scene
      if (!deferredNav) deferredNav = { type: 'prev', value: '' };
    } else if (s.type === 38 || s.type === 39 || s.type === 7) {
      // PLAYTEXT, FONT, HOTSPOT - handled in render or ignored
    } else if (s.type === 27 && cmd.autoShowedBmp) {
      // Skip ADDBMP if it was auto-shown on scene load (ADDBMP+PREV pattern)
      console.log('Skipping ADDBMP (auto-showed on arrival):', s.string);
    } else {
      executeStringCommand(s.type, s.string);
    }
  }

  // Now execute deferred HTML and/or navigation
  if (deferredHtml) {
    playHtml(deferredHtml.value);
    if (deferredNav) {
      // HTML shown + navigation pending: navigate when HTML is closed
      pendingAfterHtml = { nav: deferredNav };
    } else {
      pendingAfterHtml = { cmd: cmd, startIdx: deferredHtml.idx + 1 };
    }
  } else if (deferredNav) {
    if (videoPlaying) {
      if (currentVideo) {
        // Video is playing in DOM - wait for it to end
        waitingForVideoEnd = true; // Block clicks while video plays
        var nav = deferredNav;
        var vid = currentVideo;
        function onVideoEnd() {
          vid.removeEventListener('ended', onVideoEnd);
          vid.removeEventListener('error', onVideoEnd);
          vid.removeEventListener('click', onVideoEnd);
          waitingForVideoEnd = false; // Re-enable clicks
          closeVideo();
          doNavigation(nav);
        }
        vid.addEventListener('ended', onVideoEnd);
        vid.addEventListener('error', onVideoEnd);
        vid.addEventListener('click', onVideoEnd);
      } else if (pendingVideoPlay) {
        // Video autoplay was blocked - store nav for when video plays via unlock
        waitingForVideoEnd = true;
        pendingVideoNav = deferredNav;
      } else {
        // No video actually playing/pending, navigate now
        doNavigation(deferredNav);
      }
    } else {
      doNavigation(deferredNav);
    }
  }
}

function logHistory(action) {
  var stack = sceneHistory.map(function(h) { return h.entry.name + ':' + (h.sceneIndex + 1); });
  var current = (currentVNDEntry ? currentVNDEntry.name : '?') + ':' + (currentSceneIndex + 1);
  var blocked = waitingForVideoEnd ? ' [BLOCKED]' : '';
  var msg = action + ' | ' + current + blocked + ' | [' + (stack.length ? stack.join(', ') : '-') + ']';
  console.log('  HISTORY:', msg);
  var dbg = document.getElementById('debug-history');
  if (dbg) dbg.textContent = msg;
}

function doNavigation(nav) {
  if (nav.type === 'scene') {
    // Push current location to history before navigating (same project)
    if (currentSceneIndex >= 0 && currentVNDEntry) {
      sceneHistory.push({ entry: currentVNDEntry, sceneIndex: currentSceneIndex });
      logHistory('SCENE ' + nav.value + ' - pushed ' + currentVNDEntry.name + ':' + (currentSceneIndex + 1));
    }
    var idx = parseInt(nav.value, 10);
    if (!isNaN(idx) && idx >= 1 && (idx - 1) < project.scenes.length) {
      goToScene(idx - 1);
    } else if (project) {
      var target = project.scenes.findIndex(function(sc) {
        return sc.name.toLowerCase() === nav.value.toLowerCase();
      });
      if (target >= 0) goToScene(target);
    }
  } else if (nav.type === 'runprj') {
    // Push current location to history before external navigation
    if (currentSceneIndex >= 0 && currentVNDEntry) {
      sceneHistory.push({ entry: currentVNDEntry, sceneIndex: currentSceneIndex });
      logHistory('RUNPRJ ' + nav.value + ' - pushed ' + currentVNDEntry.name + ':' + (currentSceneIndex + 1));
    }
    executeRunPrj(nav.value);
  } else if (nav.type === 'prev') {
    // Go back to previous location in history (supports cross-project)
    if (sceneHistory.length > 0) {
      var prev = sceneHistory.pop();
      // Validate history entry
      if (!prev || !prev.entry) {
        console.error('NAV: PREV - invalid history entry:', prev);
        logHistory('PREV - invalid entry (skipped)');
        return;
      }
      logHistory('PREV - popped ' + prev.entry.name + ':' + (prev.sceneIndex + 1));
      // Check if we need to load a different project
      if (prev.entry !== currentVNDEntry) {
        // Cross-project navigation: reload the previous VND
        console.log('NAV: PREV - cross-project to', prev.entry.name);
        loadVNDEntryAndGoToScene(prev.entry, prev.sceneIndex);
      } else {
        // Same project, just go to scene
        goToScene(prev.sceneIndex);
      }
    } else {
      console.log('NAV: PREV - history empty, staying at', currentVNDEntry ? currentVNDEntry.name : '?', 'scene', currentSceneIndex + 1);
    }
  }
}

// Load a VND entry and go to a specific scene (for cross-project PREV)
function loadVNDEntryAndGoToScene(entry, sceneIndex) {
  // Validate entry object
  if (!entry || !entry.vnd || !entry.name) {
    console.error('CROSS-PROJECT: invalid entry', entry);
    waitingForVideoEnd = false;
    return;
  }
  console.log('CROSS-PROJECT: loading', entry.name, 'scene', sceneIndex + 1);
  waitingForVideoEnd = true; // Block clicks during cross-project loading
  stopAllAudio();
  currentBasePath = entry.base;

  // Load both VNP and VND, but wait for BOTH before going to scene
  var vnpPromise = fetch('/game-data/' + entry.vnp)
    .then(function(r) { return r.text(); })
    .then(function(text) {
      currentVNPConfig = parseVNP(text);
      console.log('VNP loaded for', entry.name);
    })
    .catch(function() { currentVNPConfig = null; });

  var vndPromise = fetch('/game-data/' + entry.vnd)
    .then(function(r) { return r.arrayBuffer(); });

  Promise.all([vnpPromise, vndPromise]).then(function(results) {
    var buf = results[1];
    loadVNDFile(buf, entry.vnd, true);
    currentVNDEntry = entry;
    // Update VND selector
    var vndIdx = VND_LIST.indexOf(entry);
    if (vndIdx >= 0) document.getElementById('vnd-select').value = vndIdx;
    preloadResources(function() {
      waitingForVideoEnd = false; // Re-enable clicks
      console.log('CROSS-PROJECT: now going to scene', sceneIndex + 1);
      goToScene(sceneIndex);
    });
  }).catch(function(e) {
    console.error('PREV cross-project load failed:', e);
    waitingForVideoEnd = false; // Re-enable clicks on error
  });
}

canvas.addEventListener('click', function(e) {
  // Block clicks while waiting for video to end
  if (waitingForVideoEnd) {
    console.log('Click blocked: waiting for video to end, waitingForVideoEnd=' + waitingForVideoEnd);
    return;
  }
  var pos = screenToGame(e.clientX, e.clientY);
  console.log('Canvas click at game coords:', pos.x, pos.y);
  // Find ALL commands at click point, execute side effects for all
  var allCmds = findAllCommandsAtPoint(pos.x, pos.y);
  if (allCmds.length === 0) {
    console.log('No commands found at click point');
    return;
  }
  console.log('Found', allCmds.length, 'command(s) at click point');
  // Execute non-navigable commands first (set_var, addbmp, etc.)
  allCmds.forEach(function(cmd) {
    var hasNav = cmd.strings.some(function(s) { return s.type === 6 || s.type === 31 || s.type === 3; });
    if (!hasNav) handleCommandClick(cmd);
  });
  // Then execute the navigable command (if any)
  var navCmd = allCmds.find(function(cmd) {
    return cmd.strings.some(function(s) { return s.type === 6 || s.type === 31 || s.type === 3; });
  });
  if (navCmd) handleCommandClick(navCmd);
  else if (allCmds.length > 0) {
    // All were non-navigable, already handled above
  }
});

// =============================================================================
// NAVIGATION
// =============================================================================

function goToScene(index) {
  if (!project || index < 0 || index >= project.scenes.length) return;
  currentSceneIndex = index;
  scrollX = 0;
  // Smart audio: keep sounds that the new scene will also play
  var keepKeys = getSceneAutoWavKeys(project.scenes[index]);
  stopAudioExcept(keepKeys);
  closeHtmlOverlay();
  closeSceneHtml();
  closeVideo();
  activePlayText = null;
  activePlayTextFont = null;
  activePlayTexts = [];
  overlayTexts = {};
  loadSceneBackground(project.scenes[index]);

  // DEBUG: Log scene structure for analysis
  var scene = project.scenes[index];
  console.log('=== SCENE ' + (index+1) + ': ' + scene.name + ' ===');
  console.log('Fields:', JSON.stringify(scene.fields));
  console.log('Hotspot:', scene.hotspot ? JSON.stringify(scene.hotspot) : 'none');
  scene.commands.forEach(function(cmd, ci) {
    var hasPolygon = cmd.paramPairs.length > 0;
    var strDescr = cmd.strings.map(function(s) {
      return '[' + s.type + ':' + (CMD_NAMES[s.type] || '?') + '] ' + s.string.substring(0, 80);
    }).join(' | ');
    console.log('  C' + ci + (hasPolygon ? ' (poly)' : '') + ': type=' + cmd.commandType + ' ' + strDescr);
  });

  executeSceneCommands(project.scenes[index]);
  // Load toolbar overlay if available and not navigating to toolbar itself
  if (toolbarSceneIndex >= 0 && index !== toolbarSceneIndex) {
    executeToolbar();
  }
  updateUI();
  resizeCanvas();
  // Update debug display
  logHistory('AT ' + (currentVNDEntry ? currentVNDEntry.name : '?') + ':' + (index + 1));
}

function updateUI() {
  if (!project) return;
  var scene = project.scenes[currentSceneIndex];
  var select = document.getElementById('scene-select');
  select.value = currentSceneIndex;

  document.getElementById('scene-info').textContent =
    project.header.projectName + ' - ' + project.header.width + 'x' + project.header.height;

  // Scene list
  var items = document.querySelectorAll('#scene-list .scene-item');
  items.forEach(function(el, i) {
    el.classList.toggle('active', i === currentSceneIndex);
  });
}

// =============================================================================
// CHARGEMENT VND
// =============================================================================

function loadVNDFile(arrayBuffer, fileName, skipFirstScene) {
  try {
    project = parseVND(arrayBuffer);
    console.log('Loaded:', project.header.projectName, project.scenes.length, 'scenes', project.bytesRemaining, 'bytes remaining');

    // Init variables from VND header (only set if not already defined — preserves cross-module vars)
    if (project.variables) {
      project.variables.forEach(function(v) {
        if (gameVars[v.name.toLowerCase()] === undefined) {
          gameVars[v.name.toLowerCase()] = v.value;
        }
      });
      console.log('Variables:', JSON.stringify(gameVars));
    }

    // Setup canvas internal size
    canvas.width = project.header.width;
    canvas.height = project.header.height;
    resizeCanvas();

    // Scene select
    var select = document.getElementById('scene-select');
    select.innerHTML = '';
    project.scenes.forEach(function(s, i) {
      var opt = document.createElement('option');
      opt.value = i;
      opt.textContent = (i + 1) + ': ' + (s.name || '(vide)');
      select.appendChild(opt);
    });

    // Scene list
    var list = document.getElementById('scene-list');
    list.innerHTML = '';
    project.scenes.forEach(function(s, i) {
      var div = document.createElement('div');
      div.className = 'scene-item';
      var cmdCount = s.commands.length;
      var polyCount = s.commands.filter(function(c) { return c.paramPairs.length > 0; }).length;
      div.innerHTML = '<div class="scene-name">' + (i + 1) + ': ' + (s.name || '(vide)') + '</div>' +
        '<div class="scene-meta">' + cmdCount + ' cmds, ' + polyCount + ' polys' +
        (s.fields.resource ? ', res: ' + s.fields.resource : '') +
        (s.hotspot ? ', hotspot t=' + s.hotspot.timerValue : '') + '</div>';
      div.onclick = function() { goToScene(i); };
      list.appendChild(div);
    });

    // Detect toolbar scene
    toolbarSceneIndex = -1;
    for (var ti = 0; ti < project.scenes.length; ti++) {
      if (project.scenes[ti].name && project.scenes[ti].name.toLowerCase() === 'toolbar') {
        toolbarSceneIndex = ti;
        console.log('Toolbar scene found at index', ti);
        break;
      }
    }

    // Cacher la dropzone
    document.getElementById('dropzone').classList.add('hidden');

    // Aller à la première scène (sauf si preloading)
    if (!skipFirstScene) goToScene(0);

  } catch (e) {
    alert('Erreur de chargement: ' + e.message);
    console.error(e);
  }
}

// =============================================================================
// CHARGEMENT RESSOURCES
// =============================================================================

function loadResourceFiles(fileList) {
  Array.from(fileList).forEach(function(file) {
    var name = file.name.toLowerCase();
    if (!name.endsWith('.bmp') && !name.endsWith('.jpg') && !name.endsWith('.png')) return;

    var path = (file.webkitRelativePath || file.name).toLowerCase().replace(/\\/g, '/');
    // Garder le chemin relatif (ex: "interface/jeu.bmp")
    var parts = path.split('/');
    // Stocker sous différentes clés pour maximiser les chances de match
    var reader = new FileReader();
    reader.onload = function(e) {
      var img = new Image();
      img.onload = function() {
        // Clé = nom du fichier
        resources[name] = img;
        // Clé = chemin relatif depuis le dernier dossier connu
        for (var i = 0; i < parts.length; i++) {
          resources[parts.slice(i).join('/')] = img;
        }
        console.log('Loaded resource:', path);
        render(); // Re-render si on est déjà sur une scène
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

// =============================================================================
// SERVER-BASED LOADING
// =============================================================================

// Liste des VND disponibles sur le serveur
var VND_LIST = [
  { name: 'couleurs1', vnd: 'couleurs1/couleurs1.vnd', vnp: 'couleurs1/couleurs1.vnp', base: 'couleurs1/' },
  { name: 'start', vnd: 'frontal/start.vnd', vnp: 'frontal/start.vnp', base: 'frontal/' },
  { name: 'barre', vnd: 'barre/barre.vnd', vnp: 'barre/barre.vnp', base: 'barre/' },
  { name: 'allem', vnd: 'allem/allem.vnd', vnp: 'allem/allem.vnp', base: 'allem/' },
  { name: 'angleterre', vnd: 'angl/angleterre.vnd', vnp: 'angl/angleterre.vnp', base: 'angl/' },
  { name: 'autriche', vnd: 'autr/autr.vnd', vnp: 'autr/autr.vnp', base: 'autr/' },
  { name: 'belgique', vnd: 'belge/belge.vnd', vnp: 'belge/belge.vnp', base: 'belge/' },
  { name: 'biblio', vnd: 'biblio/biblio.vnd', vnp: 'biblio/biblio.vnp', base: 'biblio/' },
  { name: 'danemark', vnd: 'danem/danem.vnd', vnp: 'danem/danem.vnp', base: 'danem/' },
  { name: 'ecosse', vnd: 'ecosse/ecosse.vnd', vnp: 'ecosse/ecosse.vnp', base: 'ecosse/' },
  { name: 'espagne', vnd: 'espa/espa.vnd', vnp: 'espa/espa.vnp', base: 'espa/' },
  { name: 'finlande', vnd: 'finlan/finlan.vnd', vnp: 'finlan/finlan.vnp', base: 'finlan/' },
  { name: 'france', vnd: 'france/france.vnd', vnp: 'france/france.vnp', base: 'france/' },
  { name: 'grece', vnd: 'grece/grece.vnd', vnp: 'grece/grece.vnp', base: 'grece/' },
  { name: 'hollande', vnd: 'holl/holl.vnd', vnp: 'holl/holl.vnp', base: 'holl/' },
  { name: 'irlande', vnd: 'irland/irland.vnd', vnp: 'irland/irland.vnp', base: 'irland/' },
  { name: 'italie', vnd: 'italie/italie.vnd', vnp: 'italie/italie.vnp', base: 'italie/' },
  { name: 'portugal', vnd: 'portu/portu.vnd', vnp: 'portu/portu.vnp', base: 'portu/' },
  { name: 'suede', vnd: 'suede/suede.vnd', vnp: 'suede/suede.vnp', base: 'suede/' },
];

var currentVNPConfig = null; // parsed VNP config
var currentBasePath = ''; // ex: 'couleurs1/'

// Populer le select VND
var vndSelect = document.getElementById('vnd-select');
VND_LIST.forEach(function(entry, i) {
  var opt = document.createElement('option');
  opt.value = i;
  opt.textContent = entry.name;
  vndSelect.appendChild(opt);
});

// Charger un VND depuis le serveur
function loadFromServer(entry) {
  stopAllAudio();
  currentBasePath = entry.base;
  currentVNDEntry = entry; // Track current VND for cross-project PREV
  sceneHistory = []; // Reset history when loading from UI (new game session)
  // Charger le VNP d'abord pour les paths
  fetch('/game-data/' + entry.vnp).then(function(r) { return r.text(); }).then(function(text) {
    currentVNPConfig = parseVNP(text);
    console.log('VNP config:', currentVNPConfig);
  }).catch(function() { currentVNPConfig = null; });

  // Charger le VND
  fetch('/game-data/' + entry.vnd).then(function(r) {
    return r.arrayBuffer();
  }).then(function(buf) {
    loadVNDFile(buf, entry.vnd, true); // skipFirstScene=true
    preloadResources(function() {
      goToScene(0);
    });
  }).catch(function(e) {
    alert('Erreur chargement: ' + e.message);
  });
}

// Parser un VNP (format INI simple)
function parseVNP(text) {
  var config = {};
  text.split('\n').forEach(function(line) {
    line = line.trim();
    if (!line || line.startsWith('[') || line.startsWith(';')) return;
    var eq = line.indexOf('=');
    if (eq < 0) return;
    config[line.substring(0, eq).trim().toUpperCase()] = line.substring(eq + 1).trim();
  });
  return config;
}

// Résoudre le chemin d'une ressource BMP
// VND ref: "euroland\bureaubanquier.bmp" -> /game-data/couleurs1/img24/euroland/bureaubanquier.bmp
function resolveResourcePath(resRef) {
  var normalized = resRef.toLowerCase().replace(/\\/g, '/');
  var imgDir = 'img24/'; // default
  if (currentVNPConfig) {
    var dir = currentVNPConfig['IMG24'] || currentVNPConfig['IMG8'] || '';
    imgDir = dir.replace(/\\/g, '/');
    if (imgDir && !imgDir.endsWith('/')) imgDir += '/';
  }
  return '/game-data/' + currentBasePath + imgDir + normalized;
}

// Charger automatiquement l'image de fond d'une scène
function loadSceneBackground(scene) {
  if (!scene.fields.resource) return;
  var resKey = scene.fields.resource.toLowerCase().replace(/\\/g, '/');
  if (resources[resKey]) return; // déjà chargé

  var url = resolveResourcePath(scene.fields.resource);
  var img = new Image();
  img.onload = function() {
    resources[resKey] = img;
    console.log('Loaded BMP:', resKey, img.width + 'x' + img.height);
    render();
  };
  img.onerror = function() {
    console.warn('Failed to load:', url);
  };
  img.src = url;
}

// =============================================================================
// PRE-LOADING / CACHE
// =============================================================================

var preloadCache = {}; // url -> Image (persistent across scenes)

function collectAllResourceUrls() {
  if (!project) return [];
  var urls = {};

  project.scenes.forEach(function(scene) {
    // Background BMP
    if (scene.fields.resource) {
      var url = resolveResourcePath(scene.fields.resource);
      urls[url] = true;
    }
    // Scan commands for ADDBMP, PLAYBMP, etc.
    scene.commands.forEach(function(cmd) {
      cmd.strings.forEach(function(s) {
        if (s.type === 27) { // ADDBMP: "name path flags x y [w h]"
          var parts = s.string.trim().split(/\s+/);
          if (parts.length >= 2) urls[resolveOverlayPath(parts[1])] = true;
        } else if (s.type === 10) { // PLAYBMP: "path flags x y"
          var parts = s.string.trim().split(/\s+/);
          if (parts.length >= 1) urls[resolveOverlayPath(parts[0])] = true;
        }
      });
    });
  });

  return Object.keys(urls);
}

function preloadResources(onComplete) {
  var urls = collectAllResourceUrls();
  if (urls.length === 0) { onComplete(); return; }

  var overlay = document.getElementById('loading-overlay');
  var barFill = document.getElementById('loading-bar-fill');
  var loadingText = document.getElementById('loading-text');
  overlay.classList.add('visible');

  // Try to load noir.bmp as background
  var noirUrl = '/game-data/' + currentBasePath + (currentVNPConfig ? (currentVNPConfig['IMG24'] || 'img24').replace(/\\/g, '/') : 'img24') + '/interface/noir.bmp';
  var bgCanvas = document.getElementById('loading-bg');
  var bgCtx = bgCanvas.getContext('2d');
  bgCtx.fillStyle = '#000';
  bgCtx.fillRect(0, 0, 640, 480);

  var noirImg = new Image();
  noirImg.onload = function() { bgCtx.drawImage(noirImg, 0, 0, 640, 480); };
  noirImg.src = noirUrl;

  var loaded = 0;
  var total = urls.length;

  function tick() {
    loaded++;
    var pct = Math.round(loaded / total * 100);
    barFill.style.width = pct + '%';
    loadingText.textContent = loaded + '/' + total + ' ressources';
    if (loaded >= total) {
      overlay.classList.remove('visible');
      onComplete();
    }
  }

  urls.forEach(function(url) {
    if (preloadCache[url]) { tick(); return; }
    var img = new Image();
    img.onload = function() {
      preloadCache[url] = img;
      // Also store in resources dict by key
      var resKey = url.replace(/^\/game-data\/[^/]+\/(?:img24|img8)\//i, '').toLowerCase();
      resources[resKey] = img;
      tick();
    };
    img.onerror = function() { tick(); }; // count failures too
    img.src = url;
  });
}

vndSelect.onchange = function() {
  var idx = parseInt(vndSelect.value);
  if (!isNaN(idx) && VND_LIST[idx]) {
    loadFromServer(VND_LIST[idx]);
  }
};

// =============================================================================
// EVENT HANDLERS
// =============================================================================

// File input
document.getElementById('file-input').addEventListener('change', function(e) {
  if (e.target.files.length > 0) {
    var file = e.target.files[0];
    var reader = new FileReader();
    reader.onload = function(ev) { loadVNDFile(ev.target.result, file.name); };
    reader.readAsArrayBuffer(file);
  }
});

document.getElementById('res-input').addEventListener('change', function(e) {
  if (e.target.files.length > 0) loadResourceFiles(e.target.files);
});

// Buttons
document.getElementById('btn-load').onclick = function() { document.getElementById('file-input').click(); };
document.getElementById('btn-load-res').onclick = function() { document.getElementById('res-input').click(); };
document.getElementById('btn-prev').onclick = function() { if (currentSceneIndex > 0) goToScene(currentSceneIndex - 1); };
document.getElementById('btn-next').onclick = function() { if (project && currentSceneIndex < project.scenes.length - 1) goToScene(currentSceneIndex + 1); };
document.getElementById('scene-select').onchange = function(e) { goToScene(parseInt(e.target.value)); };

document.getElementById('btn-scenes').onclick = function() {
  document.getElementById('scene-list').classList.toggle('visible');
};

document.getElementById('chk-polygons').onchange = function(e) { showPolygons = e.target.checked; render(); };
document.getElementById('chk-labels').onchange = function(e) { showLabels = e.target.checked; render(); };
document.getElementById('chk-fill').onchange = function(e) { fillPolygons = e.target.checked; render(); };

// Fullscreen
document.getElementById('btn-fullscreen').onclick = function() {
  if (document.fullscreenElement) {
    document.exitFullscreen();
  } else {
    document.documentElement.requestFullscreen();
  }
};
document.addEventListener('fullscreenchange', function() {
  document.body.classList.toggle('fullscreen', !!document.fullscreenElement);
  setTimeout(resizeCanvas, 100);
});

// Drag & drop
var dropArea = document.getElementById('drop-area');
dropArea.onclick = function() { document.getElementById('file-input').click(); };

['dragenter', 'dragover'].forEach(function(ev) {
  document.body.addEventListener(ev, function(e) {
    e.preventDefault();
    dropArea.classList.add('dragover');
  });
});
['dragleave', 'drop'].forEach(function(ev) {
  document.body.addEventListener(ev, function(e) {
    e.preventDefault();
    dropArea.classList.remove('dragover');
  });
});
document.body.addEventListener('drop', function(e) {
  e.preventDefault();
  var files = e.dataTransfer.files;
  for (var i = 0; i < files.length; i++) {
    if (files[i].name.toLowerCase().endsWith('.vnd')) {
      var reader = new FileReader();
      var file = files[i];
      reader.onload = function(ev) { loadVNDFile(ev.target.result, file.name); };
      reader.readAsArrayBuffer(file);
    }
  }
});

// Keyboard
document.addEventListener('keydown', function(e) {
  if (!project) return;
  if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    if (currentSceneIndex > 0) goToScene(currentSceneIndex - 1);
    e.preventDefault();
  } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    if (currentSceneIndex < project.scenes.length - 1) goToScene(currentSceneIndex + 1);
    e.preventDefault();
  } else if (e.key === 'f' || e.key === 'F') {
    document.getElementById('btn-fullscreen').click();
  } else if (e.key === 'p' || e.key === 'P') {
    document.getElementById('chk-polygons').click();
  } else if (e.key === 'l' || e.key === 'L') {
    document.getElementById('chk-labels').click();
  }
});

// Scroll horizontal pour scènes larges
var isDragging = false;
var dragStartX = 0;
var dragStartScroll = 0;

canvas.addEventListener('wheel', function(e) {
  if (!project || currentSceneIndex < 0) return;
  var scene = project.scenes[currentSceneIndex];
  var sceneW = getSceneWidth(scene);
  var gameW = project.header.width;
  if (sceneW <= gameW) return;
  e.preventDefault();
  scrollX += e.deltaY || e.deltaX;
  scrollX = Math.max(0, Math.min(scrollX, sceneW - gameW));
  render();
}, { passive: false });

canvas.addEventListener('mousedown', function(e) {
  if (!project || currentSceneIndex < 0) return;
  var scene = project.scenes[currentSceneIndex];
  if (getSceneWidth(scene) <= project.header.width) return;
  if (e.button === 1 || e.shiftKey) { // middle-click ou shift+clic
    isDragging = true;
    dragStartX = e.clientX;
    dragStartScroll = scrollX;
    e.preventDefault();
  }
});

window.addEventListener('mousemove', function(e) {
  if (!isDragging) return;
  var rect = canvas.getBoundingClientRect();
  var gameW = project.header.width;
  var scale = gameW / rect.width;
  scrollX = dragStartScroll - (e.clientX - dragStartX) * scale;
  var scene = project.scenes[currentSceneIndex];
  scrollX = Math.max(0, Math.min(scrollX, getSceneWidth(scene) - gameW));
  render();
});

window.addEventListener('mouseup', function() { isDragging = false; });

// Touch pour mobile : scroll + tap + long-press
var touchStartX = 0;
var touchStartY = 0;
var touchStartScroll = 0;
var touchMoved = false;
var longPressTimer = null;
var longPressTriggered = false;

canvas.addEventListener('touchstart', function(e) {
  e.preventDefault();
  if (!project || currentSceneIndex < 0) return;
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
  touchStartScroll = scrollX;
  touchMoved = false;
  longPressTriggered = false;

  // Long-press : afficher le texte rollover après 400ms
  clearTimeout(longPressTimer);
  var tx = e.touches[0].clientX, ty = e.touches[0].clientY;
  longPressTimer = setTimeout(function() {
    if (touchMoved) return;
    longPressTriggered = true;
    var pos = screenToGame(tx, ty);
    var cmd = findCommandAtPoint(pos.x, pos.y);
    if (cmd !== hoveredCmd) {
      hoveredCmd = cmd;
      activePlayTexts = [];
      if (cmd) evaluateHoverEffects(cmd);
      render();
    }
  }, 400);
}, { passive: false });

canvas.addEventListener('touchmove', function(e) {
  e.preventDefault();
  if (!project || currentSceneIndex < 0) return;
  var dx = Math.abs(e.touches[0].clientX - touchStartX);
  var dy = Math.abs(e.touches[0].clientY - touchStartY);
  if (dx > 8 || dy > 8) {
    touchMoved = true;
    clearTimeout(longPressTimer);
  }
  // Scroll horizontal
  var scene = project.scenes[currentSceneIndex];
  var sceneW = getSceneWidth(scene);
  var gameW = project.header.width;
  if (sceneW <= gameW) return;
  var rect = canvas.getBoundingClientRect();
  var scale = gameW / rect.width;
  scrollX = touchStartScroll - (e.touches[0].clientX - touchStartX) * scale;
  scrollX = Math.max(0, Math.min(scrollX, sceneW - gameW));
  render();
}, { passive: false });

canvas.addEventListener('touchend', function(e) {
  e.preventDefault();
  clearTimeout(longPressTimer);

  // Si long-press actif, juste masquer le hover
  if (longPressTriggered) {
    hoveredCmd = null;
    render();
    return;
  }

  if (touchMoved || !project || currentSceneIndex < 0) return;
  // Tap = clic
  var touch = e.changedTouches[0];
  var pos = screenToGame(touch.clientX, touch.clientY);
  var cmd = findClickableCommandAtPoint(pos.x, pos.y);

  // Clear hover state after tap to avoid stuck tooltips/rollovers
  hoveredCmd = null;
  activePlayTexts = [];

  if (!cmd) {
    render();
    return;
  }
  handleCommandClick(cmd);
  render(); // Refresh display after action (e.g., item pickup)
}, { passive: false });

// =============================================================================
// DEBUG PANEL
// =============================================================================

var debugVisible = false;
document.getElementById('btn-debug').onclick = function() {
  debugVisible = !debugVisible;
  document.getElementById('debug-panel').style.display = debugVisible ? 'block' : 'none';
};

var debugLogEl = document.getElementById('debug-log');
var _origLog = console.log;
var _origWarn = console.warn;
var _origError = console.error;

function debugLog(color, args) {
  var text = Array.from(args).map(function(a) {
    if (typeof a === 'object') return JSON.stringify(a, null, 1);
    return String(a);
  }).join(' ');
  var line = document.createElement('div');
  line.style.color = color;
  line.style.borderBottom = '1px solid #222';
  line.style.padding = '1px 0';
  line.textContent = text;
  debugLogEl.appendChild(line);
  // Keep max 200 lines
  while (debugLogEl.children.length > 200) debugLogEl.removeChild(debugLogEl.firstChild);
  debugLogEl.scrollTop = debugLogEl.scrollHeight;
}

console.log = function() { _origLog.apply(console, arguments); debugLog('#0f0', arguments); };
console.warn = function() { _origWarn.apply(console, arguments); debugLog('#ff0', arguments); };
console.error = function() { _origError.apply(console, arguments); debugLog('#f44', arguments); };

function debugClearLog() { debugLogEl.innerHTML = ''; }

function debugDumpVars() {
  var nonZero = {};
  Object.keys(gameVars).forEach(function(k) { if (gameVars[k] !== 0) nonZero[k] = gameVars[k]; });
  console.log('=== VARIABLES (non-zero) ===');
  console.log(nonZero);
  console.log('Total vars:', Object.keys(gameVars).length, ', non-zero:', Object.keys(nonZero).length);
}

function debugDumpScene() {
  if (!project || currentSceneIndex < 0) return;
  var s = project.scenes[currentSceneIndex];
  console.log('=== SCENE', currentSceneIndex + 1, ':', s.name, '===');
  console.log('Resource:', s.fields.resource);
  console.log('Rect:', s.rect);
  console.log('Commands:', s.commands.length);
  console.log('Hotspot:', s.hotspot);
}

function debugDumpCmds() {
  if (!project || currentSceneIndex < 0) return;
  var s = project.scenes[currentSceneIndex];
  console.log('=== COMMANDS for scene', currentSceneIndex + 1, '===');
  s.commands.forEach(function(c, i) {
    var strDesc = c.strings.map(function(s) { return '[' + s.type + '] ' + s.string; }).join(' | ');
    console.log('#' + i + ' type=' + c.commandType + ' poly=' + c.paramPairs.length + 'pts: ' + strDesc);
  });
}

function debugSetVar() {
  var name = document.getElementById('debug-var-name').value;
  var val = parseInt(document.getElementById('debug-var-val').value) || 0;
  if (name) {
    setVar(name, val);
    console.log('DEBUG SET:', name, '=', val);
  }
}

// Burger menu for mobile
function openBurgerMenu() {
  // Sync checkbox states before opening
  document.getElementById('chk-polygons-mobile').checked = document.getElementById('chk-polygons').checked;
  document.getElementById('chk-labels-mobile').checked = document.getElementById('chk-labels').checked;
  document.getElementById('chk-fill-mobile').checked = document.getElementById('chk-fill').checked;
  document.getElementById('burger-menu').classList.add('open');
}

// Initial resize
resizeCanvas();
</script>

<!-- Debug elements outside canvas-container for reliable mobile positioning -->
<div id="debug-history" style="position:fixed;top:0;left:0;right:0;background:rgba(0,0,0,0.85);color:#0f0;font:11px monospace;padding:6px 8px;z-index:9999;max-height:80px;overflow:auto;word-break:break-all;"></div>
<button id="debug-toggle" onclick="var d=document.getElementById('debug-history');d.style.display=d.style.display==='none'?'block':'none';" style="position:fixed;bottom:10px;right:10px;z-index:9999;background:#222;color:#0f0;border:2px solid #0f0;padding:10px 14px;font:bold 14px monospace;border-radius:6px;touch-action:manipulation;-webkit-tap-highlight-color:transparent;">DBG</button>
</body>
</html>
